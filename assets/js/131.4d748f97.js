(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{512:function(t,a,r){"use strict";r.r(a);var i=r(1),n=Object(i.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"题目大意"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#题目大意","aria-hidden":"true"}},[t._v("#")]),t._v(" 题目大意")]),t._v(" "),r("p",[t._v("给你一个序列，叫你找出该序列中的一个最长连续子序列[left,right]使得a[left]为这段序列的最小值，a[right]为这段序列的最大值。")]),t._v(" "),r("h2",{attrs:{id:"问题分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 问题分析")]),t._v(" "),r("p",[t._v("首先假设当前存在区间[l,r]，那么如果我们能用O(1)的时间返回这个区间的最大值所处位置a，以及最小值所处位置b，如果a<b的话区间[a,b]就是一组可行解，然后再分别递归调用[l,a-1] ，以及[b+1,r]即可，如果a>b,则对三段分别进行递归调用即可解决问题。那么，我们需要怎么样事先处理好区间[l,r]的最大值呢？")]),t._v(" "),r("h2",{attrs:{id:"rmq问题的st算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rmq问题的st算法","aria-hidden":"true"}},[t._v("#")]),t._v(" RMQ问题的ST算法")]),t._v(" "),r("p",[t._v("这就是一个经典的RMQ问题("),r("em",[t._v("Range Minimum/Maximum Query")]),t._v(")，我们采用ST算法也就是倍增来解决。用f[i][j]表示从i开始长度为2^j的区间的最小值，那么很容易得出状态转移方程:$f[i][j]=min{f[i][j-1],f[i+(1<<(j-1))][j-1]}​$,这样一来只需要O(nlogn)的时间就可以求出一个区间的最值了。接下来就是查询，我们令k为满足2^k<=R-L+1的最大整数，则以L为开头，以R为结尾的两个长度为2^k的区间合并起来即覆盖了查询区间[L,R],$k=trunc(log(R-L+1))​$,最后的查询结果即为$min{f[L][k],f[R-(1<<k)+1][k]}​$.")]),t._v(" "),r("h2",{attrs:{id:"预处理代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#预处理代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 预处理代码")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("void RMQ_init()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tf[i][0]=a[i];\n\tfor(int j=1;(1<<j)<=n;j++)\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++)\n\t\t\tf[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);\n}\n")])])]),r("h2",{attrs:{id:"查询代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查询代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 查询代码")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("int find(int L,int R)\n{\n\tint k=trunc(log2(R-L+1));\n\treturn min(f[L][k],f[R-(1<<k)+1][k]);\n}\n")])])])])},[],!1,null,null,null);a.default=n.exports}}]);