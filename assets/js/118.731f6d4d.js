(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{119:function(t,r,n){"use strict";n.r(r);var c=n(2),e=Object(c.a)({},function(){var t=this,r=t.$createElement,n=t._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"线段树的定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线段树的定义","aria-hidden":"true"}},[t._v("#")]),t._v(" 线段树的定义")]),t._v(" "),n("p",[t._v("线段树("),n("em",[t._v("segment tree")]),t._v(")是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。\n使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。")]),t._v(" "),n("h2",{attrs:{id:"线段树的作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线段树的作用","aria-hidden":"true"}},[t._v("#")]),t._v(" 线段树的作用")]),t._v(" "),n("blockquote",[n("blockquote",[n("p",[t._v("有一列数，初始值全为0，每次可以进行以下三种操作中的一种：\n(1)给指定区间每个数加上一个值\n(2)将指定区间所有数置成一个统一的值\n(3)询问一个区间上的最小值、最大值、所有数的和")])])]),t._v(" "),n("h2",{attrs:{id:"线段树的存储"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线段树的存储","aria-hidden":"true"}},[t._v("#")]),t._v(" 线段树的存储")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("struct Node\n{\n\tint left,right;\n\tint min,max,sum;\n\tNode *leftchild,*rightchild;\n}\n")])])]),n("h2",{attrs:{id:"线段树的构造"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线段树的构造","aria-hidden":"true"}},[t._v("#")]),t._v(" 线段树的构造")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void build(Node *cur,int l,int r)\n{\n\tcur->left=l;\n\tcur->right=r;\n\tif(l!=r)\n\t{\n\t\tcur->leftchild=new Node;\n\t\tcur->rightchild=new Node;\n\t\tbuild(cur->leftchild,l,(l+r)/2);\n\t\tbuild(cur->rightchild,(l+r)/2+1,r);\n\t}\n\telse\n\t\tcur->leftchild=cur->rightchild=NULL;\n}\n")])])]),n("h2",{attrs:{id:"在线段树上对元素进行修改"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在线段树上对元素进行修改","aria-hidden":"true"}},[t._v("#")]),t._v(" 在线段树上对元素进行修改")]),t._v(" "),n("p",[t._v("将线段树上位置为x的元素修改成num")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void insert(Node *cur,int x,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->left==cur->right)\n\t\tcur->min=cur->max=cur->sum=num;\n\telse\n\t{\n\t\tif(x<=(cur->left+cur->right)/2)\n\t\t\tinsert(lc,x,num);\n\t\tif(x>(cur->left+cur->right)/2)\n\t\t\tinsert(rc,x,num);\n\t\tcur->sum=lc->sum+rc->sum;\n\t\tcur->max=max(lc->max,rc->max);\n\t\tcur->min=min(lc->min,rc->min);\n\t}\n}\n")])])]),n("h2",{attrs:{id:"对线段树的某一个区间进行询问"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对线段树的某一个区间进行询问","aria-hidden":"true"}},[t._v("#")]),t._v(" 对线段树的某一个区间进行询问")]),t._v(" "),n("p",[t._v("询问区间[l,r]所有元素和")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int querysum(Node *cur,int l,int r)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tint ret=0;\n\tif((l<=cur->left)&&(cur->right<=r))\n\t\tret+=cur->sum;\n\telse\n\t{\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tret+=querysum(lc,l,r);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tret+=querysum(rc,l,r);\n\t}\n\treturn ret;\n}\n")])])]),n("h2",{attrs:{id:"那么对于整个区间进行操作呢？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#那么对于整个区间进行操作呢？","aria-hidden":"true"}},[t._v("#")]),t._v(" 那么对于整个区间进行操作呢？")]),t._v(" "),n("p",[t._v("是不是需要对每一个元素都进行insert()操作呢？\n显然不行，那样的话每一次操作都要$O(nlogn)$，失去了线段树的优势。")]),t._v(" "),n("h3",{attrs:{id:"lazy-tag技术："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lazy-tag技术：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),n("strong",[t._v("lazy-tag")]),t._v("技术：")]),t._v(" "),n("blockquote",[n("blockquote",[n("p",[t._v("lazy-tag的思想就是在对区间进行更新的时候，在分解出来的区间上打上作用于整个子树的标记\n当在对这个区间进行维护或者查询的时候便将这个标记进行分解，并将其传递到它的两个子树上。")])])]),t._v(" "),n("h2",{attrs:{id:"对一个区间整体加上一个数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对一个区间整体加上一个数","aria-hidden":"true"}},[t._v("#")]),t._v(" 对一个区间整体加上一个数")]),t._v(" "),n("p",[t._v("将区间[l,r]整体加上delta")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void update(Node *cur,int l,int r,int delta)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif((l<=cur->left)&&(cur->right<=r))\n\t\tcur->delta+=delta;\n\telse\n\t{\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tupdate(lc,l,r,delta);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tupdate(rc,l,r,delta);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n}\n")])])]),n("h2",{attrs:{id:"使用lazy-tag技术对元素进行修改"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用lazy-tag技术对元素进行修改","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用"),n("strong",[t._v("lazy-tag")]),t._v("技术对元素进行修改")]),t._v(" "),n("p",[t._v("将位置为x的元素修改为num")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void insert(Node *cur,int x,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->left==cur->right)\n\t{\n\t\tcur->sum=num;\n\t\tcur->delta=0;\n\t}\n\telse\n\t{\n\t\tlc->delta+=cur->delta;\n\t\trc->delta+=cur->delta;\n\t\tcur->delta=0;\n\t\tif(x<=(cur->left+cur->right)/2)\n\t\t\tinsert(lc,x,num);\n\t\tif(x>(cur->left+cur->right)/2)\n\t\t\tinsert(rc,x,num);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n}\n")])])]),n("h2",{attrs:{id:"使用lazy-tag技术对区间进行查询"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用lazy-tag技术对区间进行查询","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用"),n("strong",[t._v("lazy-tag")]),t._v("技术对区间进行查询")]),t._v(" "),n("p",[t._v("询问区间[l,r]上所有元素的和")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int querysum(Node *cur,int l,int r)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tint ret=0;\n\tif((l<=cur->left)&&(cur->right<=r))\n\t\tret+=cur->sum+(cur->right-cur->left+1)*cur->delta;\n\telse\n\t{\n\t\tlc->delta+=cur->delta;\n\t\trc->delta+=cur->delta;\n\t\tcur->delta=0;\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tret+=querysum(lc,l,r);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tret+=querysum(rc,l,r);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n\treturn ret;\n}\n")])])]),n("h2",{attrs:{id:"将一个区间整体置为一个数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将一个区间整体置为一个数","aria-hidden":"true"}},[t._v("#")]),t._v(" 将一个区间整体置为一个数")]),t._v(" "),n("p",[t._v("额外维护两个域en表示一个区间是否为统一的数，若en有效，则data域表示区间统一的数的数值。\n同样，我们可以用"),n("strong",[t._v("lazy-tag")]),t._v("来维护这种操作")]),t._v(" "),n("h2",{attrs:{id:"求一个节点表示区间上所有元素的和"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#求一个节点表示区间上所有元素的和","aria-hidden":"true"}},[t._v("#")]),t._v(" 求一个节点表示区间上所有元素的和")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("inline int clacsum(Node *cur)\n{\n\tif(cur->en)\n\t\treturn (cur->right-cur->left+1)*cur->data;\n\treturn cur->sum;\n}\n")])])]),n("h2",{attrs:{id:"修改一个节点的值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修改一个节点的值","aria-hidden":"true"}},[t._v("#")]),t._v(" 修改一个节点的值")]),t._v(" "),n("p",[t._v("将位置为x的元素修改为num")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void insert(Node *cur,int x,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->left==cur->right)\n\t{\n\t\tcur->sum=num;\n\t\tcur->en=false;\n\t}\n\telse\n\t{\n\t\tif(cur->en)\n\t\t{\n\t\t\tlc->data=rc->data=cur->data;\n\t\t\tlc->en=rc->en=true;\n\t\t\tcur->en=false;\n\t\t}\n\t\tif(x<=(cur->left+cur->right)/2)\n\t\t\tinsert(lc,x,num);\n\t\tif(x>(cur->left+cur->right)/2)\n\t\t\tinsert(rc,x,num);\n\t\tcur->sum=clacsum(lc)+clacsum(rc);\n\t}\n}\n")])])]),n("h2",{attrs:{id:"修改整个区间的值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修改整个区间的值","aria-hidden":"true"}},[t._v("#")]),t._v(" 修改整个区间的值")]),t._v(" "),n("p",[t._v("将区间[l,r]上所有元素的值置为num")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void update(Node *cur,int l,int r,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->en)\n\t{\n\t\tif(lc!=NULL)\n\t\t{\n\t\t\tlc->data=num;\n\t\t\tlc->en=true;\n\t\t}\n\t\tif(rc!=NULL)\n\t\t{\n\t\t\trc->data=num;\n\t\t\trc->en=true;\n\t\t}\n\t}\n\tif((l<=cur->left)&&(cur->right<=r))\n\t{\n\t\tcur->en=true;\n\t\tcur->data=num;\n\t}\n\telse\n\t{\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tupdate(lc,l,r,num);\n\t\tif(r>(cur->left+cur->right))\n\t\t\tupdate(rc,l,r,num);\n\t\tcur->sum=calcsum(lc)+calcsum(rc);\n\t}\n}\n")])])]),n("h2",{attrs:{id:"查询区间的和"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#查询区间的和","aria-hidden":"true"}},[t._v("#")]),t._v(" 查询区间的和")]),t._v(" "),n("p",[t._v("询问区间[l,r]上所有元素的和")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int querysum(Node *cur,int l,int r)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tint ret=0;\n\tif((l<=cur->left)&&(cur->right<=r))\\\n\t\tret+=clacsum(cur);\n\telse\n\t{\n\t\tif(cur->en)\n\t\t{\n\t\t\tlc->data=cur->data;\n\t\t\tlc->en=true;\n\t\t\trc->data=cur->data;\n\t\t\trc->en=true;\n\t\t\tcur->en=false;\n\t\t}\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tret+=querysum(lc,l,r);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tret+=querysum(rc,l,r);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n\treturn ret;\n}\n")])])]),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[n("strong",[t._v("到这里就差不多写完了，把所有操作的代码汇个总:")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nstruct Node\n{\n\tint left,right;\n\tint min,max,sum,delta;\n\tbool en;\n\tNode *leftchild,*rightchild;\n};\n\nvoid build(Node *cur,int l,int r)\n{\n\tcur->left=l;\n\tcur->right=r;\n\tif(l!=r)\n\t{\n\t\tcur->leftchild=new Node;\n\t\tcur->rightchild=new Node;\n\t\tbuild(cur->leftchild,l,(l+r)/2);\n\t\tbuild(cur->rightchild,(l+r)/2+1,r);\n\t}\n\telse\n\t\tcur->leftchild=cur->rightchild=NULL;\n}\n\nvoid insert(Node *cur,int x,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->left==cur->right)\n\t\tcur->min=cur->max=cur->sum=num;\n\telse\n\t{\n\t\tif(x<=(cur->left+cur->right)/2)\n\t\t\tinsert(lc,x,num);\n\t\tif(x>(cur->left+cur->right)/2)\n\t\t\tinsert(rc,x,num);\n\t\tcur->sum=lc->sum+rc->sum;\n\t\tcur->max=max(lc->max,rc->max);\n\t\tcur->min=min(lc->min,rc->min);\n\t}\n}\n\nint querysum(Node *cur,int l,int r)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tint ret=0;\n\tif((l<=cur->left)&&(cur->right<=r))\n\t\tret+=cur->sum;\n\telse\n\t{\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tret+=querysum(lc,l,r);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tret+=querysum(rc,l,r);\n\t}\n\treturn ret;\n}\n\n//range\nvoid update(Node *cur,int l,int r,int delta)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif((l<=cur->left)&&(cur->right<=r))\n\t\tcur->delta+=delta;\n\telse\n\t{\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tupdate(lc,l,r,delta);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tupdate(rc,l,r,delta);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n}\n\nvoid insert(Node *cur,int x,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->left==cur->right)\n\t{\n\t\tcur->sum=num;\n\t\tcur->delta=0;\n\t}\n\telse\n\t{\n\t\tlc->delta+=cur->delta;\n\t\trc->delta+=cur->delta;\n\t\tcur->delta=0;\n\t\tif(x<=(cur->left+cur->right)/2)\n\t\t\tinsert(lc,x,num);\n\t\tif(x>(cur->left+cur->right)/2)\n\t\t\tinsert(rc,x,num);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n}\n\nint querysum(Node *cur,int l,int r)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tint ret=0;\n\tif((l<=cur->left)&&(cur->right<=r))\n\t\tret+=cur->sum+(cur->right-cur->left+1)*cur->delta;\n\telse\n\t{\n\t\tlc->delta+=cur->delta;\n\t\trc->delta+=cur->delta;\n\t\tcur->delta=0;\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tret+=querysum(lc,l,r);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tret+=querysum(rc,l,r);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n\treturn ret;\n}\n\n//all range\ninline int clacsum(Node *cur)\n{\n\tif(cur->en)\n\t\treturn (cur->right-cur->left+1)*cur->data;\n\treturn cur->sum;\n}\n\nvoid insert(Node *cur,int x,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->left==cur->right)\n\t{\n\t\tcur->sum=num;\n\t\tcur->en=false;\n\t}\n\telse\n\t{\n\t\tif(cur->en)\n\t\t{\n\t\t\tlc->data=rc->data=cur->data;\n\t\t\tlc->en=rc->en=true;\n\t\t\tcur->en=false;\n\t\t}\n\t\tif(x<=(cur->left+cur->right)/2)\n\t\t\tinsert(lc,x,num);\n\t\tif(x>(cur->left+cur->right)/2)\n\t\t\tinsert(rc,x,num);\n\t\tcur->sum=clacsum(lc)+clacsum(rc);\n\t}\n}\n\nvoid update(Node *cur,int l,int r,int num)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tif(cur->en)\n\t{\n\t\tif(lc!=NULL)\n\t\t{\n\t\t\tlc->data=num;\n\t\t\tlc->en=true;\n\t\t}\n\t\tif(rc!=NULL)\n\t\t{\n\t\t\trc->data=num;\n\t\t\trc->en=true;\n\t\t}\n\t}\n\tif((l<=cur->left)&&(cur->right<=r))\n\t{\n\t\tcur->en=true;\n\t\tcur->data=num;\n\t}\n\telse\n\t{\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tupdate(lc,l,r,num);\n\t\tif(r>(cur->left+cur->right))\n\t\t\tupdate(rc,l,r,num);\n\t\tcur->sum=calcsum(lc)+calcsum(rc);\n\t}\n}\n\nint querysum(Node *cur,int l,int r)\n{\n\tNode *lc=cur->leftchild,*rc=cur->rightchild;\n\tint ret=0;\n\tif((l<=cur->left)&&(cur->right<=r))\\\n\t\tret+=clacsum(cur);\n\telse\n\t{\n\t\tif(cur->en)\n\t\t{\n\t\t\tlc->data=cur->data;\n\t\t\tlc->en=true;\n\t\t\trc->data=cur->data;\n\t\t\trc->en=true;\n\t\t\tcur->en=false;\n\t\t}\n\t\tif(l<=(cur->left+cur->right)/2)\n\t\t\tret+=querysum(lc,l,r);\n\t\tif(r>(cur->left+cur->right)/2)\n\t\t\tret+=querysum(rc,l,r);\n\t\tcur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n\t\tcur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n\t}\n\treturn ret;\n}\n")])])])])},[],!1,null,null,null);r.default=e.exports}}]);