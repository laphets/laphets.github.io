(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{227:function(n,r,t){"use strict";t.r(r);var e=t(2),i=Object(e.a)({},function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("貌似很久没有更新blog了？这次对上个学期敲的线段树题目汇个总。\n其中关于线段树的内容请移步这篇文章")]),n._v(" "),t("h2",{attrs:{id:"引子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引子","aria-hidden":"true"}},[n._v("#")]),n._v(" 引子")]),n._v(" "),t("p",[n._v("这些题都是我在上个学期OI“退役”以后在机房苦逼敲的，一直想写个题解总结下啥的但苦于没有时间，现在正好趁着寒假完成这个任务…\n在这套题解里包含着HDU,POJ,POI等的各种线段树基本题，实现全部采用链表，欢迎来看。")]),n._v(" "),t("h2",{attrs:{id:"hdu-1166-敌兵布阵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hdu-1166-敌兵布阵","aria-hidden":"true"}},[n._v("#")]),n._v(" HDU 1166 敌兵布阵")]),n._v(" "),t("h3",{attrs:{id:"题目大意"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目大意","aria-hidden":"true"}},[n._v("#")]),n._v(" 题目大意")]),n._v(" "),t("p",[n._v("简单的单个节点操作，查询区间和，线段树一敲很容易实现。")]),n._v(" "),t("h3",{attrs:{id:"代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码","aria-hidden":"true"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int maxn=200000+10;\nstruct Node\n{\n    int left,right;\n    int sum;\n}tree[maxn*10];\nint T,n,m,a,b,num[maxn];\nchar s[10];\nint build(int root,int left,int right)\n{\n    tree[root].left=left;\n    tree[root].right=right;\n    if(left==right)\n        return tree[root].sum=num[left];\n    int mid=(left+right)>>1;\n    int x=build(root*2,left,mid);\n    int y=build(root*2+1,mid+1,right);\n    return tree[root].sum=x+y;\n}\nint query(int root,int left,int right)\n{\n    if(tree[root].right<left||tree[root].left>right)\n        return 0;\n    if(left<=tree[root].left&&tree[root].right<=right)\n        return tree[root].sum;\n    int x=query(root*2,left,right);\n    int y=query(root*2+1,left,right);\n    return x+y;\n}\nint update(int root,int pos,int val)\n{\n    if(pos<tree[root].left||pos>tree[root].right)\n        return tree[root].sum;\n    if(tree[root].left==tree[root].right&&tree[root].left==pos)\n        return tree[root].sum=val;\n    int x=update(root*2,pos,val);\n    int y=update(root*2+1,pos,val);\n    return tree[root].sum=x+y;\n}\nint main()\n{\n//  freopen("1.sb","r",stdin);\n    scanf("%d",&T);\n    for(int cnt=1;cnt<=T;cnt++)\n    {\n        scanf("%d",&n);\n        for(int i=1;i<=n;i++)\n            scanf("%d",&num[i]);\n        build(1,1,n);\n        printf("Case %d:\\n",cnt);\n        while(1)\n        {\n            scanf("%s",&s);\n            if(s[0]==\'E\')\n                break;\n            int x,y;\n            if(s[0]==\'A\')   //Add\n            {\n                scanf("%d%d",&x,&y);\n                num[x]+=y;\n                update(1,x,num[x]);\n            }\n            if(s[0]==\'S\')   //Sub\n            {\n                scanf("%d%d",&x,&y);\n                num[x]-=y;\n                update(1,x,num[x]);\n            }\n            if(s[0]==\'Q\')\n            {\n                scanf("%d%d",&x,&y);\n                printf("%d\\n",query(1,x,y));\n            }\n        }\n    }\n    return 0;\n}\n')])])]),t("h2",{attrs:{id:"hdu-1757-i-hate-it"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hdu-1757-i-hate-it","aria-hidden":"true"}},[n._v("#")]),n._v(" HDU 1757 I Hate It")]),n._v(" "),t("h3",{attrs:{id:"题目大意-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目大意-2","aria-hidden":"true"}},[n._v("#")]),n._v(" 题目大意")]),n._v(" "),t("p",[n._v("单个节点的操作外加查询区间最值，同样容易实现。")]),n._v(" "),t("h3",{attrs:{id:"代码-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码-2","aria-hidden":"true"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int maxn=200000+10;\nstruct Node\n{\n    int left,right;\n    int max;\n}tree[maxn*10];\nint n,m,a,b,num[maxn];\nchar s;\ninline int max1(int a,int b)\n{\n    if(a<b)\n        return b;\n    return a;\n}\nint bulid(int root,int left,int right)\n{\n    tree[root].left=left;\n    tree[root].right=right;\n    if(left==right)\n        return tree[root].max=num[left];\n    int mid=(left+right)>>1;\n    int x=bulid(root*2,left,mid);\n    int y=bulid(root*2+1,mid+1,right);\n    return tree[root].max=max1(x,y);\n}\nint query(int root,int left,int right)\n{\n    if(tree[root].right<left||tree[root].left>right)\n        return 0;\n    if(left<=tree[root].left&&tree[root].right<=right)\n        return tree[root].max;\n    int x=query(root*2,left,right);\n    int y=query(root*2+1,left,right);\n    return max1(x,y);\n}\nint update(int root,int pos,int val)\n{\n    if(pos<tree[root].left||pos>tree[root].right)\n        return tree[root].max;\n    if(tree[root].left==tree[root].right&&tree[root].left==pos)\n        return tree[root].max=val;\n    int x=update(root*2,pos,val);\n    int y=update(root*2+1,pos,val);\n    return tree[root].max=max1(x,y);\n}\nint main()\n{\n//  freopen("1.sb","r",stdin);\n    while(cin>>n>>m)\n    {\n        for(int i=1;i<=n;i++)\n            scanf("%d",&num[i]);\n        bulid(1,1,n);\n        while(m--)\n        {\n            cin>>s;\n              \n            scanf("%d %d",&a,&b);\n            if(s==\'Q\')\n            {\n                printf("%d\\n",query(1,a,b));\n            }\n            else\n            {\n                num[a]=b;\n                update(1,a,b);\n            }\n        }\n    }\n    return 0;\n}\n')])])]),t("h2",{attrs:{id:"hdu-1698-just-a-hook"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hdu-1698-just-a-hook","aria-hidden":"true"}},[n._v("#")]),n._v(" HDU 1698 Just a Hook")]),n._v(" "),t("h3",{attrs:{id:"题目大意-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目大意-3","aria-hidden":"true"}},[n._v("#")]),n._v(" 题目大意")]),n._v(" "),t("p",[n._v("他怎么知道我打dota（逃…）。 将整个区间赋值为同一个数，这里需要用到lazy-tag。额外维护两个域en来表示一个区间是否为统一的数，若en有效，则data表示区间统一的值。")]),n._v(" "),t("h3",{attrs:{id:"代码-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码-3","aria-hidden":"true"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int maxn=1000+10;\nstruct Node\n{\n    int left,right;\n    int delta,data,sum;\n    bool en;\n    Node *leftchild,*rightchild;\n};\nint T,n,q,x,y,z;\nvoid build(Node *cur,int l,int r)\n{\n    cur->left=l;\n    cur->right=r;\n    if(l!=r)\n    {\n        cur->leftchild=new Node;\n        cur->rightchild=new Node;\n        build(cur->leftchild,l,(l+r)/2);\n        build(cur->rightchild,(l+r)/2+1,r);\n    }\n    else\n        cur->leftchild=cur->rightchild=NULL;\n}\nvoid clear(Node *cur)\n{\n    if(cur->left!=cur->right)\n    {\n        clear(cur->leftchild);\n        clear(cur->rightchild);\n    }\n    free(cur);\n}\nint calcsum(Node *cur)\n{\n    if(cur->en)\n        return (cur->right-cur->left+1)*cur->data;\n    else\n        return cur->sum;\n}\nvoid update(Node *cur,int l,int r,int num)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    if(cur->en)\n    {\n        if(lc!=NULL)\n        {\n            lc->data=cur->data;\n            lc->en=true;\n        }\n        if(rc!=NULL)\n        {\n            rc->data=cur->data;\n            rc->en=true;\n        }\n        cur->en=false;\n    }\n    if((l<=cur->left)&&(cur->right<=r))\n    {\n        cur->en=true;\n        cur->data=num;\n    }\n    else\n    {\n        if(l<=(cur->left+cur->right)/2)\n            update(lc,l,r,num);\n        if(r>(cur->left+cur->right)/2)\n            update(rc,l,r,num);\n        cur->sum=calcsum(lc)+calcsum(rc);\n    }\n}\nint querysum(Node *cur,int l,int r)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    int ret=0;\n    if((l<=cur->left)&&(cur->right<=r))\n        ret+=calcsum(cur);\n    else\n    {\n        if(cur->en)\n        {\n            lc->data=cur->data;\n            lc->en=true;\n            rc->data=cur->data;\n            rc->en=true;\n            cur->en=false;\n        }\n        if(l<=(cur->left+cur->right)/2)\n            ret+=querysum(lc,l,r);\n        if(r>(cur->left+cur->right)/2)\n            ret+=querysum(rc,l,r);\n        cur->sum=lc->sum+rc->sum;\n    }\n    return ret;\n}\nint main()\n{\n//    freopen("1.sb","r",stdin);\n    scanf("%d",&T);\n    for(int cnt=1;cnt<=T;cnt++)\n    {\n        scanf("%d%d",&n,&q);\n//        root=NULL;\n        Node *root=new Node;\n        build(root,1,n);\n        update(root,1,n,1);\n        while(q--)\n        {\n            scanf("%d%d%d",&x,&y,&z);\n            update(root,x,y,z);\n        }\n        printf("Case %d: The total value of the hook is %d.\\n",cnt,querysum(root,1,n));\n        clear(root);\n    }\n    return 0;\n}\n')])])]),t("h2",{attrs:{id:"poj-3468-a-simple-problem-with-integers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#poj-3468-a-simple-problem-with-integers","aria-hidden":"true"}},[n._v("#")]),n._v(" POJ 3468 A Simple Problem with Integers")]),n._v(" "),t("h3",{attrs:{id:"题目大意-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目大意-4","aria-hidden":"true"}},[n._v("#")]),n._v(" 题目大意")]),n._v(" "),t("p",[n._v("虽然题干是英文但应该也好懂，将区间整体加上一个数并且询问区间和，同样可以使用lazy-tag进行维护，但注意数据貌似会爆int？")]),n._v(" "),t("h3",{attrs:{id:"代码-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码-4","aria-hidden":"true"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nconst int maxn=100000+10;\ntypedef long long LL;\nstruct Node\n{\n    int left,right;\n    LL delta,sum;\n    Node *leftchild,*rightchild;\n};\nint T,n,q,x,y,z,num[maxn];\nchar s;\nvoid build(Node *cur,int l,int r)\n{\n    cur->left=l;\n    cur->right=r;\n    cur->delta=0;\n    if(l!=r)\n    {\n        cur->leftchild=new Node;\n        cur->rightchild=new Node;\n        build(cur->leftchild,l,(l+r)/2);\n        build(cur->rightchild,(l+r)/2+1,r);\n        cur->sum=cur->leftchild->sum+cur->rightchild->sum;\n        //cout<<cur->sum<<endl;\n    }\n    else\n    {\n        cur->sum=num[l];\n        //cout<<cur->sum<<endl;\n        cur->leftchild=cur->rightchild=NULL;\n    }\n         \n}\nvoid update(Node *cur,int l,int r,int delta)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    if((l<=cur->left)&&(cur->right<=r))\n        cur->delta+=delta;\n    else\n    {\n        if(l<=(cur->left+cur->right)/2)\n            update(lc,l,r,delta);\n        if(r>(cur->left+cur->right)/2)\n            update(rc,l,r,delta);\n        cur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n        cur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n    }\n}\nLL query(Node *cur,int l,int r)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    LL ret=0;\n    if((l<=cur->left)&&(cur->right<=r))\n        ret+=cur->sum+cur->delta*(cur->right-cur->left+1);\n    else\n    {\n        lc->delta+=cur->delta;\n        rc->delta+=cur->delta;\n        cur->delta=0;\n        if(l<=(cur->left+cur->right)/2)\n            ret+=query(lc,l,r);\n        if(r>(cur->left+cur->right)/2)\n            ret+=query(rc,l,r);\n        cur->sum=lc->sum+lc->delta*(lc->right-lc->left+1);\n        cur->sum+=rc->sum+rc->delta*(rc->right-rc->left+1);\n    }\n    return ret;\n}\nint main()\n{\n//  freopen("1.sb","r",stdin);\n    scanf("%d%d",&n,&q);\n    Node *root=new Node;\n    for(int i=1;i<=n;i++)\n        scanf("%d",&num[i]);\n    build(root,1,n);\n    for(int i=1;i<=q;i++)\n    {\n        cin>>s;\n        if(s==\'Q\')\n        {\n            scanf("%d%d",&x,&y);\n            printf("%lld\\n",query(root,x,y));\n        }\n        else\n        {\n            scanf("%d%d%d",&x,&y,&z);\n            update(root,x,y,z);\n        }\n    }\n     \n    return 0;\n}\n')])])]),t("h2",{attrs:{id:"poi-2001-railways"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#poi-2001-railways","aria-hidden":"true"}},[n._v("#")]),n._v(" POI 2001 Railways")]),n._v(" "),t("h3",{attrs:{id:"题目大意-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目大意-5","aria-hidden":"true"}},[n._v("#")]),n._v(" 题目大意")]),n._v(" "),t("p",[n._v("传说中的POI原题哦。同样的可以转化成区间整体加数并且询问区间和的问题。然而这个题目有点坑，一开始提交总是a不掉，最后去POI摸了数据手工对照才发现如果两个区间出现这种情况：[1,3],[3,6]，这样的话即使3这个节点超过了最大值，那么还是可行的。这里我用的处理方法是将区间的上介减1，然后再insert()的方法，具体看代码。")]),n._v(" "),t("h3",{attrs:{id:"代码-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码-5","aria-hidden":"true"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nstruct Node\n{\n    int left,right;\n    int max,delta;\n    Node *leftchild,*rightchild;\n};\nint n,m,r,k1,k2,v;\nvoid build(Node *cur,int l,int r)\n{\n    cur->left=l,cur->right=r,cur->max=0,cur->delta=0;\n    if(l!=r)\n    {\n        cur->leftchild=new Node;\n        cur->rightchild=new Node;\n        build(cur->leftchild,l,(l+r)/2);\n        build(cur->rightchild,(l+r)/2+1,r);\n    }\n    else\n        cur->leftchild=cur->rightchild=NULL;\n}\nvoid update(Node *cur,int l,int r,int delta)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    if((l<=cur->left)&&(cur->right<=r))\n        cur->delta+=delta;\n    else\n    {\n        if(l<=(cur->left+cur->right)/2)\n            update(lc,l,r,delta);\n        if(r>(cur->left+cur->right)/2)\n            update(rc,l,r,delta);\n        //\\cur->max+=cur->delta;\n        //cout<<cur->max<<endl;\n        cur->max=max(cur->max,lc->max+lc->delta);\n        cur->max=max(cur->max,rc->max+rc->delta);\n    }\n}\nint query(Node *cur,int l,int r)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    int ret=0;\n    if((l<=cur->left)&&(cur->right<=r))\n        ret=cur->max+cur->delta;\n    else\n    {\n        lc->delta+=cur->delta;\n        rc->delta+=cur->delta;\n        cur->max+=cur->delta;\n        cur->delta=0;\n        if(l<=(cur->left+cur->right)/2)\n        {\n            int x=query(lc,l,r);\n            ret=max(ret,x);\n        }\n        if(r>(cur->left+cur->right)/2)\n        {\n            int x=query(rc,l,r);\n            ret=max(ret,x);\n        }\n        cur->max=max(cur->max,lc->max+lc->delta);\n        cur->max=max(cur->max,rc->max+rc->delta);\n    }\n    return ret;\n}\nint main()\n{\n    //freopen("1.sb","r",stdin);\n    scanf("%d%d%d",&n,&m,&r);\n    Node *root=new Node;\n    build(root,1,n-1);\n    while(r--)\n    {\n        scanf("%d%d%d",&k1,&k2,&v);\n        //update(root,k1,k2,v);\n        //cout<<query(root,1,4)<<endl;\n        int maxx=query(root,k1,k2-1);\n        //cout<<maxx<<endl;\n        if(maxx+v<=m)\n        {\n            printf("T\\n");\n            update(root,k1,k2-1,v);\n        }\n        else\n            printf("F\\n");\n    }\n    return 0;\n}\n')])])]),t("h2",{attrs:{id:"poj-2777-count-color"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#poj-2777-count-color","aria-hidden":"true"}},[n._v("#")]),n._v(" POJ 2777 Count Color")]),n._v(" "),t("h3",{attrs:{id:"题目大意-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目大意-6","aria-hidden":"true"}},[n._v("#")]),n._v(" 题目大意")]),n._v(" "),t("p",[n._v("英文题，但仍然很好懂。将区间整体赋值，并且查询区间中不同数的个数。这个题的技巧在于颜色总共只有30种，那么我们可以用位操作表示每一种颜色，父节点的颜色即为子节点的按位或(or)，最后1的个数即为不同颜色的个数。")]),n._v(" "),t("h3",{attrs:{id:"代码-6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码-6","aria-hidden":"true"}},[n._v("#")]),n._v(" 代码")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=1000+10;\nstruct Node\n{\n    int left,right,data;\n    int color;\n    Node *leftchild,*rightchild;\n    bool cover;\n};\nint n,t,o,x,y,z,cnt;\nvoid build(Node *cur,int l,int r)\n{\n    cur->left=l;\n    cur->right=r;\n    cur->color=1;\n    cur->cover=false;\n    if(l!=r)\n    {\n        cur->leftchild=new Node;\n        cur->rightchild=new Node;\n        build(cur->leftchild,l,(l+r)/2);\n        build(cur->rightchild,(l+r)/2+1,r);\n    }\n    else\n        cur->leftchild=cur->rightchild=NULL;\n}\nvoid update(Node *cur,int l,int r,int value)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    if(cur->left==l&&cur->right==r)\n    {\n        cur->color=(1<<(value-1));\n        cur->cover=true;\n        return;\n    }\n    if(cur->cover)\n    {\n        cur->cover=false;\n        lc->cover=true;\n        rc->cover=true;\n        lc->color=cur->color;\n        rc->color=cur->color;\n    }\n    int mid=(cur->left+cur->right)/2;\n    if(r<=mid)\n        update(lc,l,r,value);\n    else if(l>mid)\n        update(rc,l,r,value);\n    else\n    {\n        update(lc,l,mid,value);\n        update(rc,mid+1,r,value);  \n    }\n    cur->color=lc->color|rc->color;\n}\nvoid query(Node *cur,int l,int r)\n{\n    Node *lc=cur->leftchild,*rc=cur->rightchild;\n    if(cur->cover||(cur->left==l&&cur->right==r))\n    {\n        cnt|=cur->color;\n        return;\n    }\n    int mid=(cur->left+cur->right)/2;\n    if(r<=mid)\n        query(lc,l,r);\n    else if(l>mid)\n        query(rc,l,r);\n    else\n    {\n        query(lc,l,mid);\n        query(rc,mid+1,r); \n    }  \n}\nint main()\n{\n//  freopen("1.sb","r",stdin);\n    scanf("%d%d%d",&n,&t,&o);\n    Node *root=new Node;\n    build(root,1,n);\n    while(o--)\n    {\n        char ch;\n        scanf(" %c ",&ch);\n        //cout<<ch<<endl;\n        //cin>>ch;\n        if(ch==\'C\')\n        {\n            scanf("%d%d%d",&x,&y,&z);\n            if(x>y)\n                swap(x,y);\n            update(root,x,y,z);\n        }\n        else\n        {\n            scanf("%d%d",&x,&y);\n            if(x>y)\n                swap(x,y);\n            cnt=0;\n            int ans=0;\n            query(root,x,y);\n            for(int i=0;i<t;i++)\n                if(cnt&(1<<i))\n                    ans++;\n            printf("%d\\n",ans);\n        }\n    }\n    return 0;\n}\n')])])]),t("h2",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[n._v("#")]),n._v(" 结语")]),n._v(" "),t("p",[n._v("这些题主要都属于一些模板类的题，但其中也不乏技巧类的东西。而线段树的精髓也在于，当线段完全覆盖一个节点区间时可以直接对这个节点打上标记，而不需要一直做下去。")])])},[],!1,null,null,null);r.default=i.exports}}]);