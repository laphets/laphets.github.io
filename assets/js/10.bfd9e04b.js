(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{140:function(e,s,t){"use strict";t.r(s);var a=t(2),r=Object(a.a)({},function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor","aria-hidden":"true"}},[e._v("#")]),e._v(" Constructor")]),e._v(" "),t("p",[e._v("For the derived class, it doesn't have access to the base class's private members, so it need use some public method to help access them.")]),e._v(" "),t("p",[e._v("When a program constructs a derived-class object, it first constructs the base-class object. Conceptually, that means "),t("strong",[e._v("the base-class object should be constructed before the program enters the body of the derived-class constructor")]),e._v(". C++ uses the member initializer list syntax to accomplish this.")]),e._v(" "),t("p",[e._v("For example:")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("RatedPlayer::RatedPlayer (unsigned int r, const string & fn, const string & ln, bool ht) : TableTennisPlayer(fn, ln, ht) {\n  rating = r; \n}\n")])])]),t("p",[e._v("Here, "),t("code",[e._v("TableTennisPlayer(fn, ln, ht)")]),e._v(" is the member initializer list. And should be called before "),t("code",[e._v("RatedPlayer")]),e._v("'s constructor.\nIf you miss the list initializer, it will call the "),t("strong",[e._v("default constructor")]),e._v(" for the base class.")]),e._v(" "),t("h3",{attrs:{id:"copy-constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copy-constructor","aria-hidden":"true"}},[e._v("#")]),e._v(" Copy constructor")]),e._v(" "),t("p",[e._v("Accept one argument "),t("code",[e._v("const MyClass& t")]),e._v(" a reference.\nAnd the compiler will also generate a default copy constructor.")]),e._v(" "),t("h3",{attrs:{id:"key-points"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-points","aria-hidden":"true"}},[e._v("#")]),e._v(" Key Points")]),e._v(" "),t("p",[e._v("These are the key points about constructors for derived classes:")]),e._v(" "),t("ul",[t("li",[e._v("The "),t("strong",[e._v("base-class")]),e._v(" object is "),t("strong",[e._v("constructed first")]),e._v(".")]),e._v(" "),t("li",[e._v("The derived-class constructor should pass base-class information to a base-class constructor via a "),t("strong",[e._v("member initializer list")]),e._v(".")]),e._v(" "),t("li",[e._v("The derived-class constructor should initialize the data members that were added to the derived class.")])]),e._v(" "),t("h2",{attrs:{id:"destructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#destructor","aria-hidden":"true"}},[e._v("#")]),e._v(" Destructor")]),e._v(" "),t("p",[e._v("Destroying an object occurs in the opposite order used to construct an object.That is, the body of the derived-class destructor is executed first, and then the base-class destructor is called automatically.")]),e._v(" "),t("blockquote",[t("p",[e._v("A program first calls the base-class constructor and then calls the derived-class constructor. The base-class constructor is responsible for initializing the inherited data members. The derived-class constructor is responsible for initializing any added data members.")])]),e._v(" "),t("h2",{attrs:{id:"relationship-between-derived-and-base-class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#relationship-between-derived-and-base-class","aria-hidden":"true"}},[e._v("#")]),e._v(" Relationship between derived and base class")]),e._v(" "),t("ul",[t("li",[e._v("a derived-class can use base-class's method which is not private")]),e._v(" "),t("li",[e._v("a base-class pointer can point to a derived-class object without an explicit type cast (since a derived-class contains members of the base-class, but the opposite is not true) "),t("strong",[e._v("Just in one direction, use base pointer to derived object")]),e._v(".")])]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Base-class* p = &derived-obj  // OK\nDerived-class* q = &base-obj  // Wrong, the base class may not have member of the derived class\n")])])]),t("p",[e._v("But in default, the base class pointer or reference can only invoke just base-class methods.")]),e._v(" "),t("p",[e._v("Let's see another example:")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Derived-class d1(...);\nBase-class d2(d1);\n")])])]),t("p",[e._v("Why this is acceptable? Since we know that for base-class, it has a default copy constructor, which accept a reference of "),t("code",[e._v("Base-class&")]),e._v(", but when we pass d1("),t("code",[e._v("Derived-class")]),e._v(") into it, it's translated into "),t("code",[e._v("Base-class")]),e._v(", which can be explained.")]),e._v(" "),t("p",[e._v("Therefore, you can assign a "),t("code",[e._v("Base-class")]),e._v(" with a "),t("code",[e._v("Derived-class")]),e._v(" object;")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Base-class d2 = d1;   // same as calling implicit copy constructor\n")])])]),t("ul",[t("li",[e._v("a base-class reference can refer to a derived-class object without an explicit type cast")])])])},[],!1,null,null,null);s.default=r.exports}}]);