<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线段树例题选讲 | Laphets&#39;s Blog</title>
    <meta name="description" content="Just playing around">
    <script src="/totp.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.29f03547.css" as="style"><link rel="preload" href="/assets/js/app.053856ae.js" as="script"><link rel="preload" href="/assets/js/9.9b1b6520.js" as="script"><link rel="preload" href="/assets/js/139.b301d2c8.js" as="script"><link rel="prefetch" href="/assets/js/1.f2c0a859.js"><link rel="prefetch" href="/assets/js/10.8dcb5342.js"><link rel="prefetch" href="/assets/js/100.889914ab.js"><link rel="prefetch" href="/assets/js/101.bbf094e2.js"><link rel="prefetch" href="/assets/js/102.9f0a9027.js"><link rel="prefetch" href="/assets/js/103.17bbdf0b.js"><link rel="prefetch" href="/assets/js/104.76902dfa.js"><link rel="prefetch" href="/assets/js/105.5d2b8ac1.js"><link rel="prefetch" href="/assets/js/106.847da9e5.js"><link rel="prefetch" href="/assets/js/107.1e3b73b9.js"><link rel="prefetch" href="/assets/js/108.bfefc354.js"><link rel="prefetch" href="/assets/js/109.7aff204d.js"><link rel="prefetch" href="/assets/js/11.24665d85.js"><link rel="prefetch" href="/assets/js/110.a35c6626.js"><link rel="prefetch" href="/assets/js/111.24669c34.js"><link rel="prefetch" href="/assets/js/112.9c357044.js"><link rel="prefetch" href="/assets/js/113.e5098d53.js"><link rel="prefetch" href="/assets/js/114.3bb6a40e.js"><link rel="prefetch" href="/assets/js/115.2c36934d.js"><link rel="prefetch" href="/assets/js/116.e43fb461.js"><link rel="prefetch" href="/assets/js/117.5d40c5ae.js"><link rel="prefetch" href="/assets/js/118.3d796fe9.js"><link rel="prefetch" href="/assets/js/119.e6e934df.js"><link rel="prefetch" href="/assets/js/12.34dc3b89.js"><link rel="prefetch" href="/assets/js/120.c52baa02.js"><link rel="prefetch" href="/assets/js/121.f6aa438e.js"><link rel="prefetch" href="/assets/js/122.f094e8bb.js"><link rel="prefetch" href="/assets/js/123.fb337820.js"><link rel="prefetch" href="/assets/js/124.b0709caf.js"><link rel="prefetch" href="/assets/js/125.b6e9bed7.js"><link rel="prefetch" href="/assets/js/126.d8671248.js"><link rel="prefetch" href="/assets/js/127.77c895bc.js"><link rel="prefetch" href="/assets/js/128.96b20ec3.js"><link rel="prefetch" href="/assets/js/129.71aa798a.js"><link rel="prefetch" href="/assets/js/13.e2f49b1d.js"><link rel="prefetch" href="/assets/js/130.a2c43d2c.js"><link rel="prefetch" href="/assets/js/131.7643d2fb.js"><link rel="prefetch" href="/assets/js/132.c39b8734.js"><link rel="prefetch" href="/assets/js/133.baf43d60.js"><link rel="prefetch" href="/assets/js/134.456d4661.js"><link rel="prefetch" href="/assets/js/135.34cdd6d8.js"><link rel="prefetch" href="/assets/js/136.7e70b64e.js"><link rel="prefetch" href="/assets/js/137.7d42af46.js"><link rel="prefetch" href="/assets/js/138.c21beed2.js"><link rel="prefetch" href="/assets/js/14.9c82b90b.js"><link rel="prefetch" href="/assets/js/140.bd53ebed.js"><link rel="prefetch" href="/assets/js/141.efb8bf3d.js"><link rel="prefetch" href="/assets/js/142.13c52e32.js"><link rel="prefetch" href="/assets/js/143.f6e1906e.js"><link rel="prefetch" href="/assets/js/144.9ffa27d8.js"><link rel="prefetch" href="/assets/js/145.cd8edc48.js"><link rel="prefetch" href="/assets/js/146.7fc00e5e.js"><link rel="prefetch" href="/assets/js/147.29588ff3.js"><link rel="prefetch" href="/assets/js/148.190b4276.js"><link rel="prefetch" href="/assets/js/149.3f9ff6d4.js"><link rel="prefetch" href="/assets/js/15.6aa9f41f.js"><link rel="prefetch" href="/assets/js/150.36539500.js"><link rel="prefetch" href="/assets/js/151.c7deb5b3.js"><link rel="prefetch" href="/assets/js/152.6d1a734c.js"><link rel="prefetch" href="/assets/js/153.26adfad1.js"><link rel="prefetch" href="/assets/js/154.31ea22a3.js"><link rel="prefetch" href="/assets/js/155.da644756.js"><link rel="prefetch" href="/assets/js/16.b096bfcb.js"><link rel="prefetch" href="/assets/js/17.ecaef833.js"><link rel="prefetch" href="/assets/js/18.34f15e51.js"><link rel="prefetch" href="/assets/js/19.bcc73e44.js"><link rel="prefetch" href="/assets/js/2.1572d531.js"><link rel="prefetch" href="/assets/js/20.d69720a0.js"><link rel="prefetch" href="/assets/js/21.054524f1.js"><link rel="prefetch" href="/assets/js/22.e000fb7c.js"><link rel="prefetch" href="/assets/js/23.b37bab55.js"><link rel="prefetch" href="/assets/js/24.7702f24b.js"><link rel="prefetch" href="/assets/js/25.bc2a4c9e.js"><link rel="prefetch" href="/assets/js/26.4ebc79e9.js"><link rel="prefetch" href="/assets/js/27.095b1d2c.js"><link rel="prefetch" href="/assets/js/28.ee25d7a6.js"><link rel="prefetch" href="/assets/js/29.dc6228d7.js"><link rel="prefetch" href="/assets/js/3.c0e068e6.js"><link rel="prefetch" href="/assets/js/30.e8895937.js"><link rel="prefetch" href="/assets/js/31.d28764e6.js"><link rel="prefetch" href="/assets/js/32.6659fcc7.js"><link rel="prefetch" href="/assets/js/33.68cb1735.js"><link rel="prefetch" href="/assets/js/34.f9b66372.js"><link rel="prefetch" href="/assets/js/35.5f91cb92.js"><link rel="prefetch" href="/assets/js/36.13fdf08e.js"><link rel="prefetch" href="/assets/js/37.c39eb22b.js"><link rel="prefetch" href="/assets/js/38.635dbd87.js"><link rel="prefetch" href="/assets/js/39.07a084b4.js"><link rel="prefetch" href="/assets/js/40.d7369575.js"><link rel="prefetch" href="/assets/js/41.3afe72a8.js"><link rel="prefetch" href="/assets/js/42.b242dc50.js"><link rel="prefetch" href="/assets/js/43.43743b4d.js"><link rel="prefetch" href="/assets/js/44.d2d98b69.js"><link rel="prefetch" href="/assets/js/45.c7e2ca2c.js"><link rel="prefetch" href="/assets/js/46.be7acf1c.js"><link rel="prefetch" href="/assets/js/47.d1722c43.js"><link rel="prefetch" href="/assets/js/48.950749b9.js"><link rel="prefetch" href="/assets/js/49.79c84047.js"><link rel="prefetch" href="/assets/js/5.a42f5204.js"><link rel="prefetch" href="/assets/js/50.82d91409.js"><link rel="prefetch" href="/assets/js/51.e9bf97ec.js"><link rel="prefetch" href="/assets/js/52.433c18fd.js"><link rel="prefetch" href="/assets/js/53.af189471.js"><link rel="prefetch" href="/assets/js/54.b695fdca.js"><link rel="prefetch" href="/assets/js/55.e4b131bc.js"><link rel="prefetch" href="/assets/js/56.ee435d6a.js"><link rel="prefetch" href="/assets/js/57.22d32df5.js"><link rel="prefetch" href="/assets/js/58.45a34c88.js"><link rel="prefetch" href="/assets/js/59.769b7524.js"><link rel="prefetch" href="/assets/js/6.2fb11696.js"><link rel="prefetch" href="/assets/js/60.bf04a237.js"><link rel="prefetch" href="/assets/js/61.5c8fd0af.js"><link rel="prefetch" href="/assets/js/62.4e8452ae.js"><link rel="prefetch" href="/assets/js/63.cd896300.js"><link rel="prefetch" href="/assets/js/64.9807e401.js"><link rel="prefetch" href="/assets/js/65.ea36faeb.js"><link rel="prefetch" href="/assets/js/66.487563b2.js"><link rel="prefetch" href="/assets/js/67.f155dc06.js"><link rel="prefetch" href="/assets/js/68.d2e32479.js"><link rel="prefetch" href="/assets/js/69.38f08cb5.js"><link rel="prefetch" href="/assets/js/7.4e67b76d.js"><link rel="prefetch" href="/assets/js/70.3bad6989.js"><link rel="prefetch" href="/assets/js/71.169ce310.js"><link rel="prefetch" href="/assets/js/72.029c8d95.js"><link rel="prefetch" href="/assets/js/73.366c70d2.js"><link rel="prefetch" href="/assets/js/74.d1395c13.js"><link rel="prefetch" href="/assets/js/75.9f94c2ea.js"><link rel="prefetch" href="/assets/js/76.b037507e.js"><link rel="prefetch" href="/assets/js/77.3c28dd4d.js"><link rel="prefetch" href="/assets/js/78.7c687ba9.js"><link rel="prefetch" href="/assets/js/79.4277aaeb.js"><link rel="prefetch" href="/assets/js/8.8db94e82.js"><link rel="prefetch" href="/assets/js/80.4de9621c.js"><link rel="prefetch" href="/assets/js/81.b935547b.js"><link rel="prefetch" href="/assets/js/82.c8736bb5.js"><link rel="prefetch" href="/assets/js/83.9a832880.js"><link rel="prefetch" href="/assets/js/84.e41facff.js"><link rel="prefetch" href="/assets/js/85.bd4b4b4c.js"><link rel="prefetch" href="/assets/js/86.1630fdc8.js"><link rel="prefetch" href="/assets/js/87.e03d608d.js"><link rel="prefetch" href="/assets/js/88.9f7dee63.js"><link rel="prefetch" href="/assets/js/89.abff537e.js"><link rel="prefetch" href="/assets/js/90.aca4896b.js"><link rel="prefetch" href="/assets/js/91.bebc5071.js"><link rel="prefetch" href="/assets/js/92.799a7a32.js"><link rel="prefetch" href="/assets/js/93.85392a32.js"><link rel="prefetch" href="/assets/js/94.87a4030d.js"><link rel="prefetch" href="/assets/js/95.1ed1cc48.js"><link rel="prefetch" href="/assets/js/96.aa91fd3b.js"><link rel="prefetch" href="/assets/js/97.2e2ca4a1.js"><link rel="prefetch" href="/assets/js/98.0517693a.js"><link rel="prefetch" href="/assets/js/99.29193dae.js">
    <link rel="stylesheet" href="/assets/css/0.styles.29f03547.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-a7fd266e><script src="./totp.min.js" data-v-a7fd266e></script> <div data-v-a7fd266e><div class="page-title-container" data-v-a7fd266e><div class="page-title" data-v-a7fd266e><a href="/" class="non-link router-link-active" data-v-a7fd266e>线段树例题选讲</a></div> <div class="page-time" data-v-a7fd266e>
              Thursday, February 11, 2016 5:18 AM (about 4 years ago)
          </div> <div class="page-avatar" data-v-a7fd266e></div></div> <div class="body-container" data-v-a7fd266e><div class="content" style="width: 100%;" data-v-a7fd266e><div class="content__default" data-v-a7fd266e><p>貌似很久没有更新blog了？这次对上个学期敲的线段树题目汇个总。
其中关于线段树的内容请移步这篇文章</p> <h2 id="引子"><a href="#引子" aria-hidden="true" class="header-anchor">#</a> 引子</h2> <p>这些题都是我在上个学期OI“退役”以后在机房苦逼敲的，一直想写个题解总结下啥的但苦于没有时间，现在正好趁着寒假完成这个任务…
在这套题解里包含着HDU,POJ,POI等的各种线段树基本题，实现全部采用链表，欢迎来看。</p> <h2 id="hdu-1166-敌兵布阵"><a href="#hdu-1166-敌兵布阵" aria-hidden="true" class="header-anchor">#</a> HDU 1166 敌兵布阵</h2> <h3 id="题目大意"><a href="#题目大意" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>简单的单个节点操作，查询区间和，线段树一敲很容易实现。</p> <h3 id="代码"><a href="#代码" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int sum;
}tree[maxn*10];
int T,n,m,a,b,num[maxn];
char s[10];
int build(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].sum=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=build(root*2,left,mid);
    int y=build(root*2+1,mid+1,right);
    return tree[root].sum=x+y;
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].sum;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return x+y;
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].sum;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].sum=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].sum=x+y;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        build(1,1,n);
        printf(&quot;Case %d:\n&quot;,cnt);
        while(1)
        {
            scanf(&quot;%s&quot;,&amp;s);
            if(s[0]=='E')
                break;
            int x,y;
            if(s[0]=='A')   //Add
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]+=y;
                update(1,x,num[x]);
            }
            if(s[0]=='S')   //Sub
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]-=y;
                update(1,x,num[x]);
            }
            if(s[0]=='Q')
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                printf(&quot;%d\n&quot;,query(1,x,y));
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1757-i-hate-it"><a href="#hdu-1757-i-hate-it" aria-hidden="true" class="header-anchor">#</a> HDU 1757 I Hate It</h2> <h3 id="题目大意-2"><a href="#题目大意-2" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>单个节点的操作外加查询区间最值，同样容易实现。</p> <h3 id="代码-2"><a href="#代码-2" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int max;
}tree[maxn*10];
int n,m,a,b,num[maxn];
char s;
inline int max1(int a,int b)
{
    if(a&lt;b)
        return b;
    return a;
}
int bulid(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].max=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=bulid(root*2,left,mid);
    int y=bulid(root*2+1,mid+1,right);
    return tree[root].max=max1(x,y);
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].max;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return max1(x,y);
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].max;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].max=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].max=max1(x,y);
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    while(cin&gt;&gt;n&gt;&gt;m)
    {
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        bulid(1,1,n);
        while(m--)
        {
            cin&gt;&gt;s;
              
            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
            if(s=='Q')
            {
                printf(&quot;%d\n&quot;,query(1,a,b));
            }
            else
            {
                num[a]=b;
                update(1,a,b);
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1698-just-a-hook"><a href="#hdu-1698-just-a-hook" aria-hidden="true" class="header-anchor">#</a> HDU 1698 Just a Hook</h2> <h3 id="题目大意-3"><a href="#题目大意-3" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>他怎么知道我打dota（逃…）。 将整个区间赋值为同一个数，这里需要用到lazy-tag。额外维护两个域en来表示一个区间是否为统一的数，若en有效，则data表示区间统一的值。</p> <h3 id="代码-3"><a href="#代码-3" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right;
    int delta,data,sum;
    bool en;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void clear(Node *cur)
{
    if(cur-&gt;left!=cur-&gt;right)
    {
        clear(cur-&gt;leftchild);
        clear(cur-&gt;rightchild);
    }
    free(cur);
}
int calcsum(Node *cur)
{
    if(cur-&gt;en)
        return (cur-&gt;right-cur-&gt;left+1)*cur-&gt;data;
    else
        return cur-&gt;sum;
}
void update(Node *cur,int l,int r,int num)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;en)
    {
        if(lc!=NULL)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
        }
        if(rc!=NULL)
        {
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
        }
        cur-&gt;en=false;
    }
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
    {
        cur-&gt;en=true;
        cur-&gt;data=num;
    }
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,num);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,num);
        cur-&gt;sum=calcsum(lc)+calcsum(rc);
    }
}
int querysum(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=calcsum(cur);
    else
    {
        if(cur-&gt;en)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
            cur-&gt;en=false;
        }
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+rc-&gt;sum;
    }
    return ret;
}
int main()
{
//    freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
//        root=NULL;
        Node *root=new Node;
        build(root,1,n);
        update(root,1,n,1);
        while(q--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,cnt,querysum(root,1,n));
        clear(root);
    }
    return 0;
}
</code></pre></div><h2 id="poj-3468-a-simple-problem-with-integers"><a href="#poj-3468-a-simple-problem-with-integers" aria-hidden="true" class="header-anchor">#</a> POJ 3468 A Simple Problem with Integers</h2> <h3 id="题目大意-4"><a href="#题目大意-4" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>虽然题干是英文但应该也好懂，将区间整体加上一个数并且询问区间和，同样可以使用lazy-tag进行维护，但注意数据貌似会爆int？</p> <h3 id="代码-4"><a href="#代码-4" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=100000+10;
typedef long long LL;
struct Node
{
    int left,right;
    LL delta,sum;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z,num[maxn];
char s;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
        cur-&gt;sum=cur-&gt;leftchild-&gt;sum+cur-&gt;rightchild-&gt;sum;
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
    }
    else
    {
        cur-&gt;sum=num[l];
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
    }
         
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
}
LL query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    LL ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=cur-&gt;sum+cur-&gt;delta*(cur-&gt;right-cur-&gt;left+1);
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
    return ret;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    Node *root=new Node;
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;num[i]);
    build(root,1,n);
    for(int i=1;i&lt;=q;i++)
    {
        cin&gt;&gt;s;
        if(s=='Q')
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            printf(&quot;%lld\n&quot;,query(root,x,y));
        }
        else
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
    }
     
    return 0;
}
</code></pre></div><h2 id="poi-2001-railways"><a href="#poi-2001-railways" aria-hidden="true" class="header-anchor">#</a> POI 2001 Railways</h2> <h3 id="题目大意-5"><a href="#题目大意-5" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>传说中的POI原题哦。同样的可以转化成区间整体加数并且询问区间和的问题。然而这个题目有点坑，一开始提交总是a不掉，最后去POI摸了数据手工对照才发现如果两个区间出现这种情况：[1,3],[3,6]，这样的话即使3这个节点超过了最大值，那么还是可行的。这里我用的处理方法是将区间的上介减1，然后再insert()的方法，具体看代码。</p> <h3 id="代码-5"><a href="#代码-5" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
struct Node
{
    int left,right;
    int max,delta;
    Node *leftchild,*rightchild;
};
int n,m,r,k1,k2,v;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l,cur-&gt;right=r,cur-&gt;max=0,cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        //\cur-&gt;max+=cur-&gt;delta;
        //cout&lt;&lt;cur-&gt;max&lt;&lt;endl;
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
}
int query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret=cur-&gt;max+cur-&gt;delta;
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;max+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(lc,l,r);
            ret=max(ret,x);
        }
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(rc,l,r);
            ret=max(ret,x);
        }
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
    return ret;
}
int main()
{
    //freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r);
    Node *root=new Node;
    build(root,1,n-1);
    while(r--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;k1,&amp;k2,&amp;v);
        //update(root,k1,k2,v);
        //cout&lt;&lt;query(root,1,4)&lt;&lt;endl;
        int maxx=query(root,k1,k2-1);
        //cout&lt;&lt;maxx&lt;&lt;endl;
        if(maxx+v&lt;=m)
        {
            printf(&quot;T\n&quot;);
            update(root,k1,k2-1,v);
        }
        else
            printf(&quot;F\n&quot;);
    }
    return 0;
}
</code></pre></div><h2 id="poj-2777-count-color"><a href="#poj-2777-count-color" aria-hidden="true" class="header-anchor">#</a> POJ 2777 Count Color</h2> <h3 id="题目大意-6"><a href="#题目大意-6" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>英文题，但仍然很好懂。将区间整体赋值，并且查询区间中不同数的个数。这个题的技巧在于颜色总共只有30种，那么我们可以用位操作表示每一种颜色，父节点的颜色即为子节点的按位或(or)，最后1的个数即为不同颜色的个数。</p> <h3 id="代码-6"><a href="#代码-6" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right,data;
    int color;
    Node *leftchild,*rightchild;
    bool cover;
};
int n,t,o,x,y,z,cnt;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;color=1;
    cur-&gt;cover=false;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int value)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;left==l&amp;&amp;cur-&gt;right==r)
    {
        cur-&gt;color=(1&lt;&lt;(value-1));
        cur-&gt;cover=true;
        return;
    }
    if(cur-&gt;cover)
    {
        cur-&gt;cover=false;
        lc-&gt;cover=true;
        rc-&gt;cover=true;
        lc-&gt;color=cur-&gt;color;
        rc-&gt;color=cur-&gt;color;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        update(lc,l,r,value);
    else if(l&gt;mid)
        update(rc,l,r,value);
    else
    {
        update(lc,l,mid,value);
        update(rc,mid+1,r,value);  
    }
    cur-&gt;color=lc-&gt;color|rc-&gt;color;
}
void query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;cover||(cur-&gt;left==l&amp;&amp;cur-&gt;right==r))
    {
        cnt|=cur-&gt;color;
        return;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        query(lc,l,r);
    else if(l&gt;mid)
        query(rc,l,r);
    else
    {
        query(lc,l,mid);
        query(rc,mid+1,r); 
    }  
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;t,&amp;o);
    Node *root=new Node;
    build(root,1,n);
    while(o--)
    {
        char ch;
        scanf(&quot; %c &quot;,&amp;ch);
        //cout&lt;&lt;ch&lt;&lt;endl;
        //cin&gt;&gt;ch;
        if(ch=='C')
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            if(x&gt;y)
                swap(x,y);
            update(root,x,y,z);
        }
        else
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            if(x&gt;y)
                swap(x,y);
            cnt=0;
            int ans=0;
            query(root,x,y);
            for(int i=0;i&lt;t;i++)
                if(cnt&amp;(1&lt;&lt;i))
                    ans++;
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre></div><h2 id="结语"><a href="#结语" aria-hidden="true" class="header-anchor">#</a> 结语</h2> <p>这些题主要都属于一些模板类的题，但其中也不乏技巧类的东西。而线段树的精髓也在于，当线段完全覆盖一个节点区间时可以直接对这个节点打上标记，而不需要一直做下去。</p></div> <!----></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.053856ae.js" defer></script><script src="/assets/js/9.9b1b6520.js" defer></script><script src="/assets/js/139.b301d2c8.js" defer></script>
  </body>
</html>
