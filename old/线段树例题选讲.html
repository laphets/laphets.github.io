<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线段树例题选讲 | Laphets&#39;s Blog</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.f47b0d32.css" as="style"><link rel="preload" href="/assets/js/app.5ae192ef.js" as="script"><link rel="preload" href="/assets/js/5.a5e17b1c.js" as="script"><link rel="preload" href="/assets/js/125.4b6c27e7.js" as="script"><link rel="prefetch" href="/assets/js/1.b84d5144.js"><link rel="prefetch" href="/assets/js/10.f9f6013c.js"><link rel="prefetch" href="/assets/js/100.3baf0caf.js"><link rel="prefetch" href="/assets/js/101.976d10fc.js"><link rel="prefetch" href="/assets/js/102.f29cfa2e.js"><link rel="prefetch" href="/assets/js/103.0290dde5.js"><link rel="prefetch" href="/assets/js/104.309adb95.js"><link rel="prefetch" href="/assets/js/105.6cf085df.js"><link rel="prefetch" href="/assets/js/106.f13e87a0.js"><link rel="prefetch" href="/assets/js/107.11796dc9.js"><link rel="prefetch" href="/assets/js/108.73f53d1c.js"><link rel="prefetch" href="/assets/js/109.7b9beff7.js"><link rel="prefetch" href="/assets/js/11.5863dbc4.js"><link rel="prefetch" href="/assets/js/110.adae2cb7.js"><link rel="prefetch" href="/assets/js/111.8e7e139a.js"><link rel="prefetch" href="/assets/js/112.c9e01bae.js"><link rel="prefetch" href="/assets/js/113.89df4ca7.js"><link rel="prefetch" href="/assets/js/114.eca23719.js"><link rel="prefetch" href="/assets/js/115.04535904.js"><link rel="prefetch" href="/assets/js/116.41bb1f41.js"><link rel="prefetch" href="/assets/js/117.7ceecd7a.js"><link rel="prefetch" href="/assets/js/118.3a979155.js"><link rel="prefetch" href="/assets/js/119.c88f7173.js"><link rel="prefetch" href="/assets/js/12.9a8c2d72.js"><link rel="prefetch" href="/assets/js/120.65dbc322.js"><link rel="prefetch" href="/assets/js/121.42a2661c.js"><link rel="prefetch" href="/assets/js/122.445392d8.js"><link rel="prefetch" href="/assets/js/123.cc15cd0c.js"><link rel="prefetch" href="/assets/js/124.5482022b.js"><link rel="prefetch" href="/assets/js/126.0ee766db.js"><link rel="prefetch" href="/assets/js/127.b5ab4bc5.js"><link rel="prefetch" href="/assets/js/128.3378eb77.js"><link rel="prefetch" href="/assets/js/129.3416c52f.js"><link rel="prefetch" href="/assets/js/13.bc27de21.js"><link rel="prefetch" href="/assets/js/130.62589fe3.js"><link rel="prefetch" href="/assets/js/131.ce31fe21.js"><link rel="prefetch" href="/assets/js/132.69502a4e.js"><link rel="prefetch" href="/assets/js/133.f6b7a58c.js"><link rel="prefetch" href="/assets/js/134.0e406a6a.js"><link rel="prefetch" href="/assets/js/135.5070c162.js"><link rel="prefetch" href="/assets/js/136.5830244e.js"><link rel="prefetch" href="/assets/js/137.b1ab8f49.js"><link rel="prefetch" href="/assets/js/138.d3427846.js"><link rel="prefetch" href="/assets/js/139.4fb613a6.js"><link rel="prefetch" href="/assets/js/14.16a08644.js"><link rel="prefetch" href="/assets/js/15.123a8266.js"><link rel="prefetch" href="/assets/js/16.702125a6.js"><link rel="prefetch" href="/assets/js/17.1dc7418b.js"><link rel="prefetch" href="/assets/js/18.e5537717.js"><link rel="prefetch" href="/assets/js/19.e56154f5.js"><link rel="prefetch" href="/assets/js/20.92fbb3ed.js"><link rel="prefetch" href="/assets/js/21.148ca21d.js"><link rel="prefetch" href="/assets/js/22.de16896e.js"><link rel="prefetch" href="/assets/js/23.da3f4c65.js"><link rel="prefetch" href="/assets/js/24.c7d85461.js"><link rel="prefetch" href="/assets/js/25.2b33a3ae.js"><link rel="prefetch" href="/assets/js/26.204ee66b.js"><link rel="prefetch" href="/assets/js/27.c5459e8b.js"><link rel="prefetch" href="/assets/js/28.becdb287.js"><link rel="prefetch" href="/assets/js/29.1f51ff3c.js"><link rel="prefetch" href="/assets/js/3.f889e8db.js"><link rel="prefetch" href="/assets/js/30.31aa08f5.js"><link rel="prefetch" href="/assets/js/31.6c0379a5.js"><link rel="prefetch" href="/assets/js/32.45c54d12.js"><link rel="prefetch" href="/assets/js/33.670050c7.js"><link rel="prefetch" href="/assets/js/34.615f8830.js"><link rel="prefetch" href="/assets/js/35.88d13455.js"><link rel="prefetch" href="/assets/js/36.a6943f44.js"><link rel="prefetch" href="/assets/js/37.15f7d87c.js"><link rel="prefetch" href="/assets/js/38.093624e4.js"><link rel="prefetch" href="/assets/js/39.99d2859b.js"><link rel="prefetch" href="/assets/js/4.a593114a.js"><link rel="prefetch" href="/assets/js/40.e761452d.js"><link rel="prefetch" href="/assets/js/41.191c2bd2.js"><link rel="prefetch" href="/assets/js/42.a2e2e830.js"><link rel="prefetch" href="/assets/js/43.29462ca8.js"><link rel="prefetch" href="/assets/js/44.00c641bd.js"><link rel="prefetch" href="/assets/js/45.7e463b49.js"><link rel="prefetch" href="/assets/js/46.b31bd7fc.js"><link rel="prefetch" href="/assets/js/47.46465d68.js"><link rel="prefetch" href="/assets/js/48.65c1e421.js"><link rel="prefetch" href="/assets/js/49.0287e72c.js"><link rel="prefetch" href="/assets/js/50.a5944e42.js"><link rel="prefetch" href="/assets/js/51.aa887d72.js"><link rel="prefetch" href="/assets/js/52.c995bcb0.js"><link rel="prefetch" href="/assets/js/53.89647514.js"><link rel="prefetch" href="/assets/js/54.052ae425.js"><link rel="prefetch" href="/assets/js/55.a74be986.js"><link rel="prefetch" href="/assets/js/56.9dc70414.js"><link rel="prefetch" href="/assets/js/57.c817df48.js"><link rel="prefetch" href="/assets/js/58.2f063de4.js"><link rel="prefetch" href="/assets/js/59.31c6da9f.js"><link rel="prefetch" href="/assets/js/6.e0cef135.js"><link rel="prefetch" href="/assets/js/60.c4144f28.js"><link rel="prefetch" href="/assets/js/61.8f8926be.js"><link rel="prefetch" href="/assets/js/62.b18392cb.js"><link rel="prefetch" href="/assets/js/63.54c98f0d.js"><link rel="prefetch" href="/assets/js/64.af5b1170.js"><link rel="prefetch" href="/assets/js/65.55d20f01.js"><link rel="prefetch" href="/assets/js/66.1a8a6e24.js"><link rel="prefetch" href="/assets/js/67.3ef9c071.js"><link rel="prefetch" href="/assets/js/68.e080d3d6.js"><link rel="prefetch" href="/assets/js/69.b0126210.js"><link rel="prefetch" href="/assets/js/7.e72501f0.js"><link rel="prefetch" href="/assets/js/70.a4db6e23.js"><link rel="prefetch" href="/assets/js/71.a83523f9.js"><link rel="prefetch" href="/assets/js/72.cb140878.js"><link rel="prefetch" href="/assets/js/73.4e8a50ef.js"><link rel="prefetch" href="/assets/js/74.fd4549ec.js"><link rel="prefetch" href="/assets/js/75.1dc9c6f7.js"><link rel="prefetch" href="/assets/js/76.1117732e.js"><link rel="prefetch" href="/assets/js/77.4cd3c879.js"><link rel="prefetch" href="/assets/js/78.f0c32056.js"><link rel="prefetch" href="/assets/js/79.7fac8099.js"><link rel="prefetch" href="/assets/js/8.10624b6e.js"><link rel="prefetch" href="/assets/js/80.4a256a37.js"><link rel="prefetch" href="/assets/js/81.d883ecd0.js"><link rel="prefetch" href="/assets/js/82.19061a72.js"><link rel="prefetch" href="/assets/js/83.82f2f479.js"><link rel="prefetch" href="/assets/js/84.03d6d064.js"><link rel="prefetch" href="/assets/js/85.ab3bb3c1.js"><link rel="prefetch" href="/assets/js/86.2af1fda6.js"><link rel="prefetch" href="/assets/js/87.4d524d27.js"><link rel="prefetch" href="/assets/js/88.eaf391d9.js"><link rel="prefetch" href="/assets/js/89.bfcdca94.js"><link rel="prefetch" href="/assets/js/9.f6b93371.js"><link rel="prefetch" href="/assets/js/90.76e20737.js"><link rel="prefetch" href="/assets/js/91.114953e2.js"><link rel="prefetch" href="/assets/js/92.c61fd36f.js"><link rel="prefetch" href="/assets/js/93.e118359b.js"><link rel="prefetch" href="/assets/js/94.977ad72b.js"><link rel="prefetch" href="/assets/js/95.1e1d19e4.js"><link rel="prefetch" href="/assets/js/96.7314cc1a.js"><link rel="prefetch" href="/assets/js/97.c74fdcbb.js"><link rel="prefetch" href="/assets/js/98.8c0ad7af.js"><link rel="prefetch" href="/assets/js/99.6abcb848.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f47b0d32.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="page-title"><a href="/" class="non-link router-link-active">线段树例题选讲</a></div> <div class="body-container"><div class="side-bar"><div class="side-title">
                  Related Topics
              </div> <div><div><a href="#引子">
                          引子
                      </a></div><div><a href="#hdu-1166-敌兵布阵">
                          HDU 1166 敌兵布阵
                      </a></div><div><a href="#题目大意">
                          题目大意
                      </a></div><div><a href="#代码">
                          代码
                      </a></div><div><a href="#hdu-1757-i-hate-it">
                          HDU 1757 I Hate It
                      </a></div><div><a href="#题目大意-2">
                          题目大意
                      </a></div><div><a href="#代码-2">
                          代码
                      </a></div><div><a href="#hdu-1698-just-a-hook">
                          HDU 1698 Just a Hook
                      </a></div><div><a href="#题目大意-3">
                          题目大意
                      </a></div><div><a href="#代码-3">
                          代码
                      </a></div><div><a href="#poj-3468-a-simple-problem-with-integers">
                          POJ 3468 A Simple Problem with Integers
                      </a></div><div><a href="#题目大意-4">
                          题目大意
                      </a></div><div><a href="#代码-4">
                          代码
                      </a></div><div><a href="#poi-2001-railways">
                          POI 2001 Railways
                      </a></div><div><a href="#题目大意-5">
                          题目大意
                      </a></div><div><a href="#代码-5">
                          代码
                      </a></div><div><a href="#poj-2777-count-color">
                          POJ 2777 Count Color
                      </a></div><div><a href="#题目大意-6">
                          题目大意
                      </a></div><div><a href="#代码-6">
                          代码
                      </a></div><div><a href="#结语">
                          结语
                      </a></div></div></div> <div class="content"><div class="content default"><p>貌似很久没有更新blog了？这次对上个学期敲的线段树题目汇个总。
其中关于线段树的内容请移步这篇文章</p> <h2 id="引子"><a href="#引子" aria-hidden="true" class="header-anchor">#</a> 引子</h2> <p>这些题都是我在上个学期OI“退役”以后在机房苦逼敲的，一直想写个题解总结下啥的但苦于没有时间，现在正好趁着寒假完成这个任务…
在这套题解里包含着HDU,POJ,POI等的各种线段树基本题，实现全部采用链表，欢迎来看。</p> <h2 id="hdu-1166-敌兵布阵"><a href="#hdu-1166-敌兵布阵" aria-hidden="true" class="header-anchor">#</a> HDU 1166 敌兵布阵</h2> <h3 id="题目大意"><a href="#题目大意" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>简单的单个节点操作，查询区间和，线段树一敲很容易实现。</p> <h3 id="代码"><a href="#代码" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int sum;
}tree[maxn*10];
int T,n,m,a,b,num[maxn];
char s[10];
int build(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].sum=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=build(root*2,left,mid);
    int y=build(root*2+1,mid+1,right);
    return tree[root].sum=x+y;
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].sum;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return x+y;
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].sum;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].sum=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].sum=x+y;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        build(1,1,n);
        printf(&quot;Case %d:\n&quot;,cnt);
        while(1)
        {
            scanf(&quot;%s&quot;,&amp;s);
            if(s[0]=='E')
                break;
            int x,y;
            if(s[0]=='A')   //Add
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]+=y;
                update(1,x,num[x]);
            }
            if(s[0]=='S')   //Sub
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]-=y;
                update(1,x,num[x]);
            }
            if(s[0]=='Q')
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                printf(&quot;%d\n&quot;,query(1,x,y));
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1757-i-hate-it"><a href="#hdu-1757-i-hate-it" aria-hidden="true" class="header-anchor">#</a> HDU 1757 I Hate It</h2> <h3 id="题目大意-2"><a href="#题目大意-2" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>单个节点的操作外加查询区间最值，同样容易实现。</p> <h3 id="代码-2"><a href="#代码-2" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int max;
}tree[maxn*10];
int n,m,a,b,num[maxn];
char s;
inline int max1(int a,int b)
{
    if(a&lt;b)
        return b;
    return a;
}
int bulid(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].max=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=bulid(root*2,left,mid);
    int y=bulid(root*2+1,mid+1,right);
    return tree[root].max=max1(x,y);
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].max;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return max1(x,y);
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].max;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].max=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].max=max1(x,y);
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    while(cin&gt;&gt;n&gt;&gt;m)
    {
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        bulid(1,1,n);
        while(m--)
        {
            cin&gt;&gt;s;
              
            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
            if(s=='Q')
            {
                printf(&quot;%d\n&quot;,query(1,a,b));
            }
            else
            {
                num[a]=b;
                update(1,a,b);
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1698-just-a-hook"><a href="#hdu-1698-just-a-hook" aria-hidden="true" class="header-anchor">#</a> HDU 1698 Just a Hook</h2> <h3 id="题目大意-3"><a href="#题目大意-3" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>他怎么知道我打dota（逃…）。 将整个区间赋值为同一个数，这里需要用到lazy-tag。额外维护两个域en来表示一个区间是否为统一的数，若en有效，则data表示区间统一的值。</p> <h3 id="代码-3"><a href="#代码-3" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right;
    int delta,data,sum;
    bool en;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void clear(Node *cur)
{
    if(cur-&gt;left!=cur-&gt;right)
    {
        clear(cur-&gt;leftchild);
        clear(cur-&gt;rightchild);
    }
    free(cur);
}
int calcsum(Node *cur)
{
    if(cur-&gt;en)
        return (cur-&gt;right-cur-&gt;left+1)*cur-&gt;data;
    else
        return cur-&gt;sum;
}
void update(Node *cur,int l,int r,int num)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;en)
    {
        if(lc!=NULL)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
        }
        if(rc!=NULL)
        {
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
        }
        cur-&gt;en=false;
    }
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
    {
        cur-&gt;en=true;
        cur-&gt;data=num;
    }
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,num);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,num);
        cur-&gt;sum=calcsum(lc)+calcsum(rc);
    }
}
int querysum(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=calcsum(cur);
    else
    {
        if(cur-&gt;en)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
            cur-&gt;en=false;
        }
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+rc-&gt;sum;
    }
    return ret;
}
int main()
{
//    freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
//        root=NULL;
        Node *root=new Node;
        build(root,1,n);
        update(root,1,n,1);
        while(q--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,cnt,querysum(root,1,n));
        clear(root);
    }
    return 0;
}
</code></pre></div><h2 id="poj-3468-a-simple-problem-with-integers"><a href="#poj-3468-a-simple-problem-with-integers" aria-hidden="true" class="header-anchor">#</a> POJ 3468 A Simple Problem with Integers</h2> <h3 id="题目大意-4"><a href="#题目大意-4" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>虽然题干是英文但应该也好懂，将区间整体加上一个数并且询问区间和，同样可以使用lazy-tag进行维护，但注意数据貌似会爆int？</p> <h3 id="代码-4"><a href="#代码-4" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=100000+10;
typedef long long LL;
struct Node
{
    int left,right;
    LL delta,sum;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z,num[maxn];
char s;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
        cur-&gt;sum=cur-&gt;leftchild-&gt;sum+cur-&gt;rightchild-&gt;sum;
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
    }
    else
    {
        cur-&gt;sum=num[l];
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
    }
         
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
}
LL query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    LL ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=cur-&gt;sum+cur-&gt;delta*(cur-&gt;right-cur-&gt;left+1);
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
    return ret;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    Node *root=new Node;
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;num[i]);
    build(root,1,n);
    for(int i=1;i&lt;=q;i++)
    {
        cin&gt;&gt;s;
        if(s=='Q')
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            printf(&quot;%lld\n&quot;,query(root,x,y));
        }
        else
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
    }
     
    return 0;
}
</code></pre></div><h2 id="poi-2001-railways"><a href="#poi-2001-railways" aria-hidden="true" class="header-anchor">#</a> POI 2001 Railways</h2> <h3 id="题目大意-5"><a href="#题目大意-5" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>传说中的POI原题哦。同样的可以转化成区间整体加数并且询问区间和的问题。然而这个题目有点坑，一开始提交总是a不掉，最后去POI摸了数据手工对照才发现如果两个区间出现这种情况：[1,3],[3,6]，这样的话即使3这个节点超过了最大值，那么还是可行的。这里我用的处理方法是将区间的上介减1，然后再insert()的方法，具体看代码。</p> <h3 id="代码-5"><a href="#代码-5" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
struct Node
{
    int left,right;
    int max,delta;
    Node *leftchild,*rightchild;
};
int n,m,r,k1,k2,v;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l,cur-&gt;right=r,cur-&gt;max=0,cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        //\cur-&gt;max+=cur-&gt;delta;
        //cout&lt;&lt;cur-&gt;max&lt;&lt;endl;
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
}
int query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret=cur-&gt;max+cur-&gt;delta;
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;max+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(lc,l,r);
            ret=max(ret,x);
        }
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(rc,l,r);
            ret=max(ret,x);
        }
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
    return ret;
}
int main()
{
    //freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r);
    Node *root=new Node;
    build(root,1,n-1);
    while(r--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;k1,&amp;k2,&amp;v);
        //update(root,k1,k2,v);
        //cout&lt;&lt;query(root,1,4)&lt;&lt;endl;
        int maxx=query(root,k1,k2-1);
        //cout&lt;&lt;maxx&lt;&lt;endl;
        if(maxx+v&lt;=m)
        {
            printf(&quot;T\n&quot;);
            update(root,k1,k2-1,v);
        }
        else
            printf(&quot;F\n&quot;);
    }
    return 0;
}
</code></pre></div><h2 id="poj-2777-count-color"><a href="#poj-2777-count-color" aria-hidden="true" class="header-anchor">#</a> POJ 2777 Count Color</h2> <h3 id="题目大意-6"><a href="#题目大意-6" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>英文题，但仍然很好懂。将区间整体赋值，并且查询区间中不同数的个数。这个题的技巧在于颜色总共只有30种，那么我们可以用位操作表示每一种颜色，父节点的颜色即为子节点的按位或(or)，最后1的个数即为不同颜色的个数。</p> <h3 id="代码-6"><a href="#代码-6" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right,data;
    int color;
    Node *leftchild,*rightchild;
    bool cover;
};
int n,t,o,x,y,z,cnt;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;color=1;
    cur-&gt;cover=false;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int value)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;left==l&amp;&amp;cur-&gt;right==r)
    {
        cur-&gt;color=(1&lt;&lt;(value-1));
        cur-&gt;cover=true;
        return;
    }
    if(cur-&gt;cover)
    {
        cur-&gt;cover=false;
        lc-&gt;cover=true;
        rc-&gt;cover=true;
        lc-&gt;color=cur-&gt;color;
        rc-&gt;color=cur-&gt;color;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        update(lc,l,r,value);
    else if(l&gt;mid)
        update(rc,l,r,value);
    else
    {
        update(lc,l,mid,value);
        update(rc,mid+1,r,value);  
    }
    cur-&gt;color=lc-&gt;color|rc-&gt;color;
}
void query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;cover||(cur-&gt;left==l&amp;&amp;cur-&gt;right==r))
    {
        cnt|=cur-&gt;color;
        return;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        query(lc,l,r);
    else if(l&gt;mid)
        query(rc,l,r);
    else
    {
        query(lc,l,mid);
        query(rc,mid+1,r); 
    }  
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;t,&amp;o);
    Node *root=new Node;
    build(root,1,n);
    while(o--)
    {
        char ch;
        scanf(&quot; %c &quot;,&amp;ch);
        //cout&lt;&lt;ch&lt;&lt;endl;
        //cin&gt;&gt;ch;
        if(ch=='C')
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            if(x&gt;y)
                swap(x,y);
            update(root,x,y,z);
        }
        else
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            if(x&gt;y)
                swap(x,y);
            cnt=0;
            int ans=0;
            query(root,x,y);
            for(int i=0;i&lt;t;i++)
                if(cnt&amp;(1&lt;&lt;i))
                    ans++;
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre></div><h2 id="结语"><a href="#结语" aria-hidden="true" class="header-anchor">#</a> 结语</h2> <p>这些题主要都属于一些模板类的题，但其中也不乏技巧类的东西。而线段树的精髓也在于，当线段完全覆盖一个节点区间时可以直接对这个节点打上标记，而不需要一直做下去。</p></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5ae192ef.js" defer></script><script src="/assets/js/5.a5e17b1c.js" defer></script><script src="/assets/js/125.4b6c27e7.js" defer></script>
  </body>
</html>
