<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线段树例题选讲 | Wenqing&#39;s Homepage</title>
    <meta name="description" content="Just playing around">
    <script src="/totp.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css">
  <link rel="icon" type="image/png" href="favicon.png">
    
    <link rel="preload" href="/assets/css/0.styles.9e431a92.css" as="style"><link rel="preload" href="/assets/js/app.57d46d41.js" as="script"><link rel="preload" href="/assets/js/9.544c10e3.js" as="script"><link rel="preload" href="/assets/js/143.3d663955.js" as="script"><link rel="prefetch" href="/assets/js/1.f2c0a859.js"><link rel="prefetch" href="/assets/js/10.613adc2b.js"><link rel="prefetch" href="/assets/js/100.d7d41c31.js"><link rel="prefetch" href="/assets/js/101.c3a526c6.js"><link rel="prefetch" href="/assets/js/102.8c88f575.js"><link rel="prefetch" href="/assets/js/103.8943f284.js"><link rel="prefetch" href="/assets/js/104.a687bb45.js"><link rel="prefetch" href="/assets/js/105.4c0a9ff5.js"><link rel="prefetch" href="/assets/js/106.5eb1fa36.js"><link rel="prefetch" href="/assets/js/107.04e8d8ca.js"><link rel="prefetch" href="/assets/js/108.b885ae94.js"><link rel="prefetch" href="/assets/js/109.e1411614.js"><link rel="prefetch" href="/assets/js/11.7a832792.js"><link rel="prefetch" href="/assets/js/110.940d815c.js"><link rel="prefetch" href="/assets/js/111.709ad236.js"><link rel="prefetch" href="/assets/js/112.55cd2913.js"><link rel="prefetch" href="/assets/js/113.47aa884d.js"><link rel="prefetch" href="/assets/js/114.6506b32a.js"><link rel="prefetch" href="/assets/js/115.22dccaf6.js"><link rel="prefetch" href="/assets/js/116.549d786f.js"><link rel="prefetch" href="/assets/js/117.13dba86f.js"><link rel="prefetch" href="/assets/js/118.2fafe030.js"><link rel="prefetch" href="/assets/js/119.aeccb061.js"><link rel="prefetch" href="/assets/js/12.a8d54814.js"><link rel="prefetch" href="/assets/js/120.08c43cf3.js"><link rel="prefetch" href="/assets/js/121.e9298dc5.js"><link rel="prefetch" href="/assets/js/122.4ab92988.js"><link rel="prefetch" href="/assets/js/123.5eb37241.js"><link rel="prefetch" href="/assets/js/124.02eb871b.js"><link rel="prefetch" href="/assets/js/125.56a35e04.js"><link rel="prefetch" href="/assets/js/126.c6e584fc.js"><link rel="prefetch" href="/assets/js/127.128ac9cd.js"><link rel="prefetch" href="/assets/js/128.6eafab04.js"><link rel="prefetch" href="/assets/js/129.ee20f186.js"><link rel="prefetch" href="/assets/js/13.bffffb22.js"><link rel="prefetch" href="/assets/js/130.558fa717.js"><link rel="prefetch" href="/assets/js/131.4d748f97.js"><link rel="prefetch" href="/assets/js/132.87dffac9.js"><link rel="prefetch" href="/assets/js/133.074909e3.js"><link rel="prefetch" href="/assets/js/134.f6155e66.js"><link rel="prefetch" href="/assets/js/135.b91c1a54.js"><link rel="prefetch" href="/assets/js/136.e1ad3746.js"><link rel="prefetch" href="/assets/js/137.9c45c022.js"><link rel="prefetch" href="/assets/js/138.255c036c.js"><link rel="prefetch" href="/assets/js/139.41f41958.js"><link rel="prefetch" href="/assets/js/14.8587f358.js"><link rel="prefetch" href="/assets/js/140.6d18a9be.js"><link rel="prefetch" href="/assets/js/141.5a15e27e.js"><link rel="prefetch" href="/assets/js/142.75eaedf9.js"><link rel="prefetch" href="/assets/js/144.917fb377.js"><link rel="prefetch" href="/assets/js/145.dcd9acc2.js"><link rel="prefetch" href="/assets/js/146.88564112.js"><link rel="prefetch" href="/assets/js/147.621843bf.js"><link rel="prefetch" href="/assets/js/148.2afedfe2.js"><link rel="prefetch" href="/assets/js/149.44002fbb.js"><link rel="prefetch" href="/assets/js/15.197798a5.js"><link rel="prefetch" href="/assets/js/150.e2406fdb.js"><link rel="prefetch" href="/assets/js/151.73b4c06f.js"><link rel="prefetch" href="/assets/js/152.408ed7b6.js"><link rel="prefetch" href="/assets/js/153.5ee2af4d.js"><link rel="prefetch" href="/assets/js/154.b59ecb12.js"><link rel="prefetch" href="/assets/js/155.c2ba735a.js"><link rel="prefetch" href="/assets/js/156.f32a7d81.js"><link rel="prefetch" href="/assets/js/157.141f5213.js"><link rel="prefetch" href="/assets/js/158.8272543b.js"><link rel="prefetch" href="/assets/js/159.0c5fa8f7.js"><link rel="prefetch" href="/assets/js/16.f4e1ed50.js"><link rel="prefetch" href="/assets/js/17.a5078981.js"><link rel="prefetch" href="/assets/js/18.aa639746.js"><link rel="prefetch" href="/assets/js/19.982c70b9.js"><link rel="prefetch" href="/assets/js/2.fa641fc1.js"><link rel="prefetch" href="/assets/js/20.e99209ef.js"><link rel="prefetch" href="/assets/js/21.c11a73f8.js"><link rel="prefetch" href="/assets/js/22.7ef6f047.js"><link rel="prefetch" href="/assets/js/23.e12c9503.js"><link rel="prefetch" href="/assets/js/24.abe69be4.js"><link rel="prefetch" href="/assets/js/25.e88863f7.js"><link rel="prefetch" href="/assets/js/26.9be527d4.js"><link rel="prefetch" href="/assets/js/27.107b226a.js"><link rel="prefetch" href="/assets/js/28.f7540370.js"><link rel="prefetch" href="/assets/js/29.75db00d7.js"><link rel="prefetch" href="/assets/js/3.7b80c9e9.js"><link rel="prefetch" href="/assets/js/30.4c57eacb.js"><link rel="prefetch" href="/assets/js/31.d19cca77.js"><link rel="prefetch" href="/assets/js/32.ace9d19a.js"><link rel="prefetch" href="/assets/js/33.2edf2752.js"><link rel="prefetch" href="/assets/js/34.802fd473.js"><link rel="prefetch" href="/assets/js/35.2d6eed3d.js"><link rel="prefetch" href="/assets/js/36.dc2dff48.js"><link rel="prefetch" href="/assets/js/37.a0aa8ab7.js"><link rel="prefetch" href="/assets/js/38.683c9779.js"><link rel="prefetch" href="/assets/js/39.3df5d854.js"><link rel="prefetch" href="/assets/js/40.30ac538e.js"><link rel="prefetch" href="/assets/js/41.a6c38c69.js"><link rel="prefetch" href="/assets/js/42.e5643b10.js"><link rel="prefetch" href="/assets/js/43.75bd9d6e.js"><link rel="prefetch" href="/assets/js/44.179f7493.js"><link rel="prefetch" href="/assets/js/45.ba23e047.js"><link rel="prefetch" href="/assets/js/46.e0d93e70.js"><link rel="prefetch" href="/assets/js/47.33e1eb65.js"><link rel="prefetch" href="/assets/js/48.3e453325.js"><link rel="prefetch" href="/assets/js/49.da1a8651.js"><link rel="prefetch" href="/assets/js/5.a2cc9fa0.js"><link rel="prefetch" href="/assets/js/50.f150855d.js"><link rel="prefetch" href="/assets/js/51.3eab562a.js"><link rel="prefetch" href="/assets/js/52.b334a51d.js"><link rel="prefetch" href="/assets/js/53.3b742a13.js"><link rel="prefetch" href="/assets/js/54.efea1b90.js"><link rel="prefetch" href="/assets/js/55.a76935ae.js"><link rel="prefetch" href="/assets/js/56.874dd080.js"><link rel="prefetch" href="/assets/js/57.aa39444e.js"><link rel="prefetch" href="/assets/js/58.2d5b8fff.js"><link rel="prefetch" href="/assets/js/59.da3ecde7.js"><link rel="prefetch" href="/assets/js/6.5e06a41e.js"><link rel="prefetch" href="/assets/js/60.88b72898.js"><link rel="prefetch" href="/assets/js/61.3254df90.js"><link rel="prefetch" href="/assets/js/62.b3aba407.js"><link rel="prefetch" href="/assets/js/63.e47fa3bd.js"><link rel="prefetch" href="/assets/js/64.47d38b89.js"><link rel="prefetch" href="/assets/js/65.2d964d84.js"><link rel="prefetch" href="/assets/js/66.ab299184.js"><link rel="prefetch" href="/assets/js/67.737a0a8c.js"><link rel="prefetch" href="/assets/js/68.14a131e9.js"><link rel="prefetch" href="/assets/js/69.c41594dd.js"><link rel="prefetch" href="/assets/js/7.e282f8dc.js"><link rel="prefetch" href="/assets/js/70.4d1e7c95.js"><link rel="prefetch" href="/assets/js/71.021928d4.js"><link rel="prefetch" href="/assets/js/72.0db0dacb.js"><link rel="prefetch" href="/assets/js/73.579bad8f.js"><link rel="prefetch" href="/assets/js/74.be4f67bb.js"><link rel="prefetch" href="/assets/js/75.077eaaf6.js"><link rel="prefetch" href="/assets/js/76.03668101.js"><link rel="prefetch" href="/assets/js/77.cd4f1d28.js"><link rel="prefetch" href="/assets/js/78.ff6e4da5.js"><link rel="prefetch" href="/assets/js/79.23159da0.js"><link rel="prefetch" href="/assets/js/8.3bd7d8a7.js"><link rel="prefetch" href="/assets/js/80.47a85246.js"><link rel="prefetch" href="/assets/js/81.71d07b52.js"><link rel="prefetch" href="/assets/js/82.42a0806b.js"><link rel="prefetch" href="/assets/js/83.dc0aa486.js"><link rel="prefetch" href="/assets/js/84.875a537d.js"><link rel="prefetch" href="/assets/js/85.ef5aa3f5.js"><link rel="prefetch" href="/assets/js/86.7e51e16c.js"><link rel="prefetch" href="/assets/js/87.5ef0bc52.js"><link rel="prefetch" href="/assets/js/88.73fe1d44.js"><link rel="prefetch" href="/assets/js/89.3dc8609a.js"><link rel="prefetch" href="/assets/js/90.52527103.js"><link rel="prefetch" href="/assets/js/91.03379cbd.js"><link rel="prefetch" href="/assets/js/92.070f0cd8.js"><link rel="prefetch" href="/assets/js/93.8cfa090b.js"><link rel="prefetch" href="/assets/js/94.1eec3984.js"><link rel="prefetch" href="/assets/js/95.0b1900b0.js"><link rel="prefetch" href="/assets/js/96.33f8389e.js"><link rel="prefetch" href="/assets/js/97.6901c31f.js"><link rel="prefetch" href="/assets/js/98.0d76cfcf.js"><link rel="prefetch" href="/assets/js/99.7178364b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9e431a92.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-993f4e32><script src="./totp.min.js" data-v-993f4e32></script> <div data-v-993f4e32><div class="page-title-container" data-v-993f4e32><div class="page-title" data-v-993f4e32><a href="/blog" class="non-link" data-v-993f4e32>线段树例题选讲</a></div> <div class="page-time" data-v-993f4e32>
              Wednesday, February 10, 2016 9:18 PM (about 7 years ago)
          </div> <div class="page-avatar" data-v-993f4e32></div></div> <div class="body-container" data-v-993f4e32><div class="content" style="width: 100%;" data-v-993f4e32><div class="content__default" data-v-993f4e32><p>貌似很久没有更新blog了？这次对上个学期敲的线段树题目汇个总。
其中关于线段树的内容请移步这篇文章</p> <h2 id="引子"><a href="#引子" aria-hidden="true" class="header-anchor">#</a> 引子</h2> <p>这些题都是我在上个学期OI“退役”以后在机房苦逼敲的，一直想写个题解总结下啥的但苦于没有时间，现在正好趁着寒假完成这个任务…
在这套题解里包含着HDU,POJ,POI等的各种线段树基本题，实现全部采用链表，欢迎来看。</p> <h2 id="hdu-1166-敌兵布阵"><a href="#hdu-1166-敌兵布阵" aria-hidden="true" class="header-anchor">#</a> HDU 1166 敌兵布阵</h2> <h3 id="题目大意"><a href="#题目大意" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>简单的单个节点操作，查询区间和，线段树一敲很容易实现。</p> <h3 id="代码"><a href="#代码" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int sum;
}tree[maxn*10];
int T,n,m,a,b,num[maxn];
char s[10];
int build(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].sum=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=build(root*2,left,mid);
    int y=build(root*2+1,mid+1,right);
    return tree[root].sum=x+y;
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].sum;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return x+y;
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].sum;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].sum=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].sum=x+y;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        build(1,1,n);
        printf(&quot;Case %d:\n&quot;,cnt);
        while(1)
        {
            scanf(&quot;%s&quot;,&amp;s);
            if(s[0]=='E')
                break;
            int x,y;
            if(s[0]=='A')   //Add
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]+=y;
                update(1,x,num[x]);
            }
            if(s[0]=='S')   //Sub
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]-=y;
                update(1,x,num[x]);
            }
            if(s[0]=='Q')
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                printf(&quot;%d\n&quot;,query(1,x,y));
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1757-i-hate-it"><a href="#hdu-1757-i-hate-it" aria-hidden="true" class="header-anchor">#</a> HDU 1757 I Hate It</h2> <h3 id="题目大意-2"><a href="#题目大意-2" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>单个节点的操作外加查询区间最值，同样容易实现。</p> <h3 id="代码-2"><a href="#代码-2" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int max;
}tree[maxn*10];
int n,m,a,b,num[maxn];
char s;
inline int max1(int a,int b)
{
    if(a&lt;b)
        return b;
    return a;
}
int bulid(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].max=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=bulid(root*2,left,mid);
    int y=bulid(root*2+1,mid+1,right);
    return tree[root].max=max1(x,y);
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].max;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return max1(x,y);
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].max;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].max=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].max=max1(x,y);
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    while(cin&gt;&gt;n&gt;&gt;m)
    {
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        bulid(1,1,n);
        while(m--)
        {
            cin&gt;&gt;s;
              
            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
            if(s=='Q')
            {
                printf(&quot;%d\n&quot;,query(1,a,b));
            }
            else
            {
                num[a]=b;
                update(1,a,b);
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1698-just-a-hook"><a href="#hdu-1698-just-a-hook" aria-hidden="true" class="header-anchor">#</a> HDU 1698 Just a Hook</h2> <h3 id="题目大意-3"><a href="#题目大意-3" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>他怎么知道我打dota（逃…）。 将整个区间赋值为同一个数，这里需要用到lazy-tag。额外维护两个域en来表示一个区间是否为统一的数，若en有效，则data表示区间统一的值。</p> <h3 id="代码-3"><a href="#代码-3" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right;
    int delta,data,sum;
    bool en;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void clear(Node *cur)
{
    if(cur-&gt;left!=cur-&gt;right)
    {
        clear(cur-&gt;leftchild);
        clear(cur-&gt;rightchild);
    }
    free(cur);
}
int calcsum(Node *cur)
{
    if(cur-&gt;en)
        return (cur-&gt;right-cur-&gt;left+1)*cur-&gt;data;
    else
        return cur-&gt;sum;
}
void update(Node *cur,int l,int r,int num)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;en)
    {
        if(lc!=NULL)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
        }
        if(rc!=NULL)
        {
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
        }
        cur-&gt;en=false;
    }
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
    {
        cur-&gt;en=true;
        cur-&gt;data=num;
    }
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,num);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,num);
        cur-&gt;sum=calcsum(lc)+calcsum(rc);
    }
}
int querysum(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=calcsum(cur);
    else
    {
        if(cur-&gt;en)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
            cur-&gt;en=false;
        }
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+rc-&gt;sum;
    }
    return ret;
}
int main()
{
//    freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
//        root=NULL;
        Node *root=new Node;
        build(root,1,n);
        update(root,1,n,1);
        while(q--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,cnt,querysum(root,1,n));
        clear(root);
    }
    return 0;
}
</code></pre></div><h2 id="poj-3468-a-simple-problem-with-integers"><a href="#poj-3468-a-simple-problem-with-integers" aria-hidden="true" class="header-anchor">#</a> POJ 3468 A Simple Problem with Integers</h2> <h3 id="题目大意-4"><a href="#题目大意-4" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>虽然题干是英文但应该也好懂，将区间整体加上一个数并且询问区间和，同样可以使用lazy-tag进行维护，但注意数据貌似会爆int？</p> <h3 id="代码-4"><a href="#代码-4" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=100000+10;
typedef long long LL;
struct Node
{
    int left,right;
    LL delta,sum;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z,num[maxn];
char s;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
        cur-&gt;sum=cur-&gt;leftchild-&gt;sum+cur-&gt;rightchild-&gt;sum;
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
    }
    else
    {
        cur-&gt;sum=num[l];
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
    }
         
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
}
LL query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    LL ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=cur-&gt;sum+cur-&gt;delta*(cur-&gt;right-cur-&gt;left+1);
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
    return ret;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    Node *root=new Node;
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;num[i]);
    build(root,1,n);
    for(int i=1;i&lt;=q;i++)
    {
        cin&gt;&gt;s;
        if(s=='Q')
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            printf(&quot;%lld\n&quot;,query(root,x,y));
        }
        else
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
    }
     
    return 0;
}
</code></pre></div><h2 id="poi-2001-railways"><a href="#poi-2001-railways" aria-hidden="true" class="header-anchor">#</a> POI 2001 Railways</h2> <h3 id="题目大意-5"><a href="#题目大意-5" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>传说中的POI原题哦。同样的可以转化成区间整体加数并且询问区间和的问题。然而这个题目有点坑，一开始提交总是a不掉，最后去POI摸了数据手工对照才发现如果两个区间出现这种情况：[1,3],[3,6]，这样的话即使3这个节点超过了最大值，那么还是可行的。这里我用的处理方法是将区间的上介减1，然后再insert()的方法，具体看代码。</p> <h3 id="代码-5"><a href="#代码-5" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
struct Node
{
    int left,right;
    int max,delta;
    Node *leftchild,*rightchild;
};
int n,m,r,k1,k2,v;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l,cur-&gt;right=r,cur-&gt;max=0,cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        //\cur-&gt;max+=cur-&gt;delta;
        //cout&lt;&lt;cur-&gt;max&lt;&lt;endl;
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
}
int query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret=cur-&gt;max+cur-&gt;delta;
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;max+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(lc,l,r);
            ret=max(ret,x);
        }
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(rc,l,r);
            ret=max(ret,x);
        }
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
    return ret;
}
int main()
{
    //freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r);
    Node *root=new Node;
    build(root,1,n-1);
    while(r--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;k1,&amp;k2,&amp;v);
        //update(root,k1,k2,v);
        //cout&lt;&lt;query(root,1,4)&lt;&lt;endl;
        int maxx=query(root,k1,k2-1);
        //cout&lt;&lt;maxx&lt;&lt;endl;
        if(maxx+v&lt;=m)
        {
            printf(&quot;T\n&quot;);
            update(root,k1,k2-1,v);
        }
        else
            printf(&quot;F\n&quot;);
    }
    return 0;
}
</code></pre></div><h2 id="poj-2777-count-color"><a href="#poj-2777-count-color" aria-hidden="true" class="header-anchor">#</a> POJ 2777 Count Color</h2> <h3 id="题目大意-6"><a href="#题目大意-6" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>英文题，但仍然很好懂。将区间整体赋值，并且查询区间中不同数的个数。这个题的技巧在于颜色总共只有30种，那么我们可以用位操作表示每一种颜色，父节点的颜色即为子节点的按位或(or)，最后1的个数即为不同颜色的个数。</p> <h3 id="代码-6"><a href="#代码-6" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right,data;
    int color;
    Node *leftchild,*rightchild;
    bool cover;
};
int n,t,o,x,y,z,cnt;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;color=1;
    cur-&gt;cover=false;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int value)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;left==l&amp;&amp;cur-&gt;right==r)
    {
        cur-&gt;color=(1&lt;&lt;(value-1));
        cur-&gt;cover=true;
        return;
    }
    if(cur-&gt;cover)
    {
        cur-&gt;cover=false;
        lc-&gt;cover=true;
        rc-&gt;cover=true;
        lc-&gt;color=cur-&gt;color;
        rc-&gt;color=cur-&gt;color;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        update(lc,l,r,value);
    else if(l&gt;mid)
        update(rc,l,r,value);
    else
    {
        update(lc,l,mid,value);
        update(rc,mid+1,r,value);  
    }
    cur-&gt;color=lc-&gt;color|rc-&gt;color;
}
void query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;cover||(cur-&gt;left==l&amp;&amp;cur-&gt;right==r))
    {
        cnt|=cur-&gt;color;
        return;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        query(lc,l,r);
    else if(l&gt;mid)
        query(rc,l,r);
    else
    {
        query(lc,l,mid);
        query(rc,mid+1,r); 
    }  
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;t,&amp;o);
    Node *root=new Node;
    build(root,1,n);
    while(o--)
    {
        char ch;
        scanf(&quot; %c &quot;,&amp;ch);
        //cout&lt;&lt;ch&lt;&lt;endl;
        //cin&gt;&gt;ch;
        if(ch=='C')
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            if(x&gt;y)
                swap(x,y);
            update(root,x,y,z);
        }
        else
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            if(x&gt;y)
                swap(x,y);
            cnt=0;
            int ans=0;
            query(root,x,y);
            for(int i=0;i&lt;t;i++)
                if(cnt&amp;(1&lt;&lt;i))
                    ans++;
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre></div><h2 id="结语"><a href="#结语" aria-hidden="true" class="header-anchor">#</a> 结语</h2> <p>这些题主要都属于一些模板类的题，但其中也不乏技巧类的东西。而线段树的精髓也在于，当线段完全覆盖一个节点区间时可以直接对这个节点打上标记，而不需要一直做下去。</p></div> <!----></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.57d46d41.js" defer></script><script src="/assets/js/9.544c10e3.js" defer></script><script src="/assets/js/143.3d663955.js" defer></script>
  </body>
</html>
