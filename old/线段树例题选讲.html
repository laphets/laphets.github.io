<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线段树例题选讲 | Wenqing&#39;s Homepage</title>
    <meta name="description" content="Just playing around">
    <script src="/totp.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css">
  <link rel="icon" type="image/png" href="favicon.png">
    
    <link rel="preload" href="/assets/css/0.styles.b2e2ca42.css" as="style"><link rel="preload" href="/assets/js/app.86401502.js" as="script"><link rel="preload" href="/assets/js/9.1d422f60.js" as="script"><link rel="preload" href="/assets/js/143.6ef7193c.js" as="script"><link rel="prefetch" href="/assets/js/1.71f0cd67.js"><link rel="prefetch" href="/assets/js/10.68e8a79e.js"><link rel="prefetch" href="/assets/js/100.ce569dae.js"><link rel="prefetch" href="/assets/js/101.48d7eced.js"><link rel="prefetch" href="/assets/js/102.0183e55f.js"><link rel="prefetch" href="/assets/js/103.1157ee8e.js"><link rel="prefetch" href="/assets/js/104.e05e43d7.js"><link rel="prefetch" href="/assets/js/105.0eab6e8e.js"><link rel="prefetch" href="/assets/js/106.c4d8c011.js"><link rel="prefetch" href="/assets/js/107.c5a49e8b.js"><link rel="prefetch" href="/assets/js/108.093fe15c.js"><link rel="prefetch" href="/assets/js/109.37d9570f.js"><link rel="prefetch" href="/assets/js/11.48662754.js"><link rel="prefetch" href="/assets/js/110.49b7e45a.js"><link rel="prefetch" href="/assets/js/111.7a8bb807.js"><link rel="prefetch" href="/assets/js/112.005ee8ac.js"><link rel="prefetch" href="/assets/js/113.a1357fa4.js"><link rel="prefetch" href="/assets/js/114.7b7d5075.js"><link rel="prefetch" href="/assets/js/115.7edeb3a4.js"><link rel="prefetch" href="/assets/js/116.4dddb462.js"><link rel="prefetch" href="/assets/js/117.ff807a13.js"><link rel="prefetch" href="/assets/js/118.76cda400.js"><link rel="prefetch" href="/assets/js/119.2524c0de.js"><link rel="prefetch" href="/assets/js/12.468dd681.js"><link rel="prefetch" href="/assets/js/120.9f0c386f.js"><link rel="prefetch" href="/assets/js/121.38d5c99d.js"><link rel="prefetch" href="/assets/js/122.9fd16701.js"><link rel="prefetch" href="/assets/js/123.819c2878.js"><link rel="prefetch" href="/assets/js/124.9dcd9af7.js"><link rel="prefetch" href="/assets/js/125.696b2c41.js"><link rel="prefetch" href="/assets/js/126.5a7d88dd.js"><link rel="prefetch" href="/assets/js/127.669ab56b.js"><link rel="prefetch" href="/assets/js/128.00c951bf.js"><link rel="prefetch" href="/assets/js/129.d4c25538.js"><link rel="prefetch" href="/assets/js/13.7777de00.js"><link rel="prefetch" href="/assets/js/130.e5098b27.js"><link rel="prefetch" href="/assets/js/131.d999eed4.js"><link rel="prefetch" href="/assets/js/132.e1297b86.js"><link rel="prefetch" href="/assets/js/133.25159a7c.js"><link rel="prefetch" href="/assets/js/134.98bc0273.js"><link rel="prefetch" href="/assets/js/135.dd00b9f5.js"><link rel="prefetch" href="/assets/js/136.0eaee5cc.js"><link rel="prefetch" href="/assets/js/137.a9ea46de.js"><link rel="prefetch" href="/assets/js/138.83cb39c4.js"><link rel="prefetch" href="/assets/js/139.5cec8ceb.js"><link rel="prefetch" href="/assets/js/14.f6b9f88b.js"><link rel="prefetch" href="/assets/js/140.cfe593e5.js"><link rel="prefetch" href="/assets/js/141.15133bad.js"><link rel="prefetch" href="/assets/js/142.4dab414e.js"><link rel="prefetch" href="/assets/js/144.ddf6900a.js"><link rel="prefetch" href="/assets/js/145.d9878f40.js"><link rel="prefetch" href="/assets/js/146.46bd43d6.js"><link rel="prefetch" href="/assets/js/147.704ab66e.js"><link rel="prefetch" href="/assets/js/148.4f51b6ce.js"><link rel="prefetch" href="/assets/js/149.f8fd1149.js"><link rel="prefetch" href="/assets/js/15.c311e056.js"><link rel="prefetch" href="/assets/js/150.ba7d0ff2.js"><link rel="prefetch" href="/assets/js/151.61d06160.js"><link rel="prefetch" href="/assets/js/152.2f61dbc8.js"><link rel="prefetch" href="/assets/js/153.3adcdebd.js"><link rel="prefetch" href="/assets/js/154.759ff33a.js"><link rel="prefetch" href="/assets/js/155.b513476b.js"><link rel="prefetch" href="/assets/js/156.828d387b.js"><link rel="prefetch" href="/assets/js/157.7c084877.js"><link rel="prefetch" href="/assets/js/158.9f7d6a88.js"><link rel="prefetch" href="/assets/js/159.cd1778f5.js"><link rel="prefetch" href="/assets/js/16.e72fa666.js"><link rel="prefetch" href="/assets/js/17.9999efcf.js"><link rel="prefetch" href="/assets/js/18.b6ae89ef.js"><link rel="prefetch" href="/assets/js/19.afd5e40a.js"><link rel="prefetch" href="/assets/js/2.7ac9e85e.js"><link rel="prefetch" href="/assets/js/20.b6586fcb.js"><link rel="prefetch" href="/assets/js/21.27f64953.js"><link rel="prefetch" href="/assets/js/22.6666006b.js"><link rel="prefetch" href="/assets/js/23.d5605f11.js"><link rel="prefetch" href="/assets/js/24.847ba82c.js"><link rel="prefetch" href="/assets/js/25.f03efcc7.js"><link rel="prefetch" href="/assets/js/26.4b05ea5d.js"><link rel="prefetch" href="/assets/js/27.27c9e50f.js"><link rel="prefetch" href="/assets/js/28.c9b5b661.js"><link rel="prefetch" href="/assets/js/29.51a69df5.js"><link rel="prefetch" href="/assets/js/3.171d93a1.js"><link rel="prefetch" href="/assets/js/30.a4b0c5c4.js"><link rel="prefetch" href="/assets/js/31.40812245.js"><link rel="prefetch" href="/assets/js/32.e601de6f.js"><link rel="prefetch" href="/assets/js/33.0634d34b.js"><link rel="prefetch" href="/assets/js/34.d0d2dfb8.js"><link rel="prefetch" href="/assets/js/35.d265214c.js"><link rel="prefetch" href="/assets/js/36.efa89456.js"><link rel="prefetch" href="/assets/js/37.613d08eb.js"><link rel="prefetch" href="/assets/js/38.821d85af.js"><link rel="prefetch" href="/assets/js/39.e8d34af1.js"><link rel="prefetch" href="/assets/js/40.c1950c55.js"><link rel="prefetch" href="/assets/js/41.2eaa0f6f.js"><link rel="prefetch" href="/assets/js/42.22ac3b25.js"><link rel="prefetch" href="/assets/js/43.e81c53dd.js"><link rel="prefetch" href="/assets/js/44.470fa970.js"><link rel="prefetch" href="/assets/js/45.58230f70.js"><link rel="prefetch" href="/assets/js/46.29632da7.js"><link rel="prefetch" href="/assets/js/47.d9a4b9ac.js"><link rel="prefetch" href="/assets/js/48.c5989e2d.js"><link rel="prefetch" href="/assets/js/49.ab4847ae.js"><link rel="prefetch" href="/assets/js/5.ce528a71.js"><link rel="prefetch" href="/assets/js/50.23a92ff7.js"><link rel="prefetch" href="/assets/js/51.c29e436c.js"><link rel="prefetch" href="/assets/js/52.5c747e8b.js"><link rel="prefetch" href="/assets/js/53.102f1745.js"><link rel="prefetch" href="/assets/js/54.238a934c.js"><link rel="prefetch" href="/assets/js/55.994f20d1.js"><link rel="prefetch" href="/assets/js/56.b4a496c0.js"><link rel="prefetch" href="/assets/js/57.ded21d57.js"><link rel="prefetch" href="/assets/js/58.f69c4564.js"><link rel="prefetch" href="/assets/js/59.66b07a06.js"><link rel="prefetch" href="/assets/js/6.ffb65d42.js"><link rel="prefetch" href="/assets/js/60.9720190a.js"><link rel="prefetch" href="/assets/js/61.6408fbd8.js"><link rel="prefetch" href="/assets/js/62.de658017.js"><link rel="prefetch" href="/assets/js/63.25952b8c.js"><link rel="prefetch" href="/assets/js/64.2c675c3d.js"><link rel="prefetch" href="/assets/js/65.644cd30d.js"><link rel="prefetch" href="/assets/js/66.eec397e5.js"><link rel="prefetch" href="/assets/js/67.4f8210b8.js"><link rel="prefetch" href="/assets/js/68.0823ab30.js"><link rel="prefetch" href="/assets/js/69.c602c706.js"><link rel="prefetch" href="/assets/js/7.2052e8ca.js"><link rel="prefetch" href="/assets/js/70.3e4fa615.js"><link rel="prefetch" href="/assets/js/71.62f06932.js"><link rel="prefetch" href="/assets/js/72.c066718b.js"><link rel="prefetch" href="/assets/js/73.c3ac39ad.js"><link rel="prefetch" href="/assets/js/74.e26172d3.js"><link rel="prefetch" href="/assets/js/75.0b2fa613.js"><link rel="prefetch" href="/assets/js/76.1ee46727.js"><link rel="prefetch" href="/assets/js/77.d2ee6d61.js"><link rel="prefetch" href="/assets/js/78.3c9ed61f.js"><link rel="prefetch" href="/assets/js/79.20109e62.js"><link rel="prefetch" href="/assets/js/8.38310c9b.js"><link rel="prefetch" href="/assets/js/80.2f234033.js"><link rel="prefetch" href="/assets/js/81.12ce2f8e.js"><link rel="prefetch" href="/assets/js/82.1ca7954f.js"><link rel="prefetch" href="/assets/js/83.a071b3ce.js"><link rel="prefetch" href="/assets/js/84.679cb7d4.js"><link rel="prefetch" href="/assets/js/85.82dbbd59.js"><link rel="prefetch" href="/assets/js/86.3100e1f7.js"><link rel="prefetch" href="/assets/js/87.15126e85.js"><link rel="prefetch" href="/assets/js/88.71eef645.js"><link rel="prefetch" href="/assets/js/89.b80038ca.js"><link rel="prefetch" href="/assets/js/90.91d09f9c.js"><link rel="prefetch" href="/assets/js/91.4915b53d.js"><link rel="prefetch" href="/assets/js/92.92a277fc.js"><link rel="prefetch" href="/assets/js/93.eb03f6a6.js"><link rel="prefetch" href="/assets/js/94.1c3fab98.js"><link rel="prefetch" href="/assets/js/95.c04881ca.js"><link rel="prefetch" href="/assets/js/96.2d7de13f.js"><link rel="prefetch" href="/assets/js/97.adcd37b6.js"><link rel="prefetch" href="/assets/js/98.f884a950.js"><link rel="prefetch" href="/assets/js/99.73c0c9d0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b2e2ca42.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-913507bc><script src="./totp.min.js" data-v-913507bc></script> <div data-v-913507bc><div class="page-title-container" data-v-913507bc><div class="page-title" data-v-913507bc><a href="/blog" class="non-link" data-v-913507bc>线段树例题选讲</a></div> <div class="page-time" data-v-913507bc>
              Wednesday, February 10, 2016 9:18 PM (about 9 years ago)
          </div> <div class="page-avatar" data-v-913507bc></div></div> <div class="body-container" data-v-913507bc><div class="content" style="width: 100%;" data-v-913507bc><div class="medium-zoom-container" data-v-913507bc><div class="content__default" data-v-913507bc><p>貌似很久没有更新blog了？这次对上个学期敲的线段树题目汇个总。
其中关于线段树的内容请移步这篇文章</p> <h2 id="引子"><a href="#引子" aria-hidden="true" class="header-anchor">#</a> 引子</h2> <p>这些题都是我在上个学期OI“退役”以后在机房苦逼敲的，一直想写个题解总结下啥的但苦于没有时间，现在正好趁着寒假完成这个任务…
在这套题解里包含着HDU,POJ,POI等的各种线段树基本题，实现全部采用链表，欢迎来看。</p> <h2 id="hdu-1166-敌兵布阵"><a href="#hdu-1166-敌兵布阵" aria-hidden="true" class="header-anchor">#</a> HDU 1166 敌兵布阵</h2> <h3 id="题目大意"><a href="#题目大意" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>简单的单个节点操作，查询区间和，线段树一敲很容易实现。</p> <h3 id="代码"><a href="#代码" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int sum;
}tree[maxn*10];
int T,n,m,a,b,num[maxn];
char s[10];
int build(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].sum=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=build(root*2,left,mid);
    int y=build(root*2+1,mid+1,right);
    return tree[root].sum=x+y;
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].sum;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return x+y;
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].sum;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].sum=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].sum=x+y;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        build(1,1,n);
        printf(&quot;Case %d:\n&quot;,cnt);
        while(1)
        {
            scanf(&quot;%s&quot;,&amp;s);
            if(s[0]=='E')
                break;
            int x,y;
            if(s[0]=='A')   //Add
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]+=y;
                update(1,x,num[x]);
            }
            if(s[0]=='S')   //Sub
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                num[x]-=y;
                update(1,x,num[x]);
            }
            if(s[0]=='Q')
            {
                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
                printf(&quot;%d\n&quot;,query(1,x,y));
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1757-i-hate-it"><a href="#hdu-1757-i-hate-it" aria-hidden="true" class="header-anchor">#</a> HDU 1757 I Hate It</h2> <h3 id="题目大意-2"><a href="#题目大意-2" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>单个节点的操作外加查询区间最值，同样容易实现。</p> <h3 id="代码-2"><a href="#代码-2" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000+10;
struct Node
{
    int left,right;
    int max;
}tree[maxn*10];
int n,m,a,b,num[maxn];
char s;
inline int max1(int a,int b)
{
    if(a&lt;b)
        return b;
    return a;
}
int bulid(int root,int left,int right)
{
    tree[root].left=left;
    tree[root].right=right;
    if(left==right)
        return tree[root].max=num[left];
    int mid=(left+right)&gt;&gt;1;
    int x=bulid(root*2,left,mid);
    int y=bulid(root*2+1,mid+1,right);
    return tree[root].max=max1(x,y);
}
int query(int root,int left,int right)
{
    if(tree[root].right&lt;left||tree[root].left&gt;right)
        return 0;
    if(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right)
        return tree[root].max;
    int x=query(root*2,left,right);
    int y=query(root*2+1,left,right);
    return max1(x,y);
}
int update(int root,int pos,int val)
{
    if(pos&lt;tree[root].left||pos&gt;tree[root].right)
        return tree[root].max;
    if(tree[root].left==tree[root].right&amp;&amp;tree[root].left==pos)
        return tree[root].max=val;
    int x=update(root*2,pos,val);
    int y=update(root*2+1,pos,val);
    return tree[root].max=max1(x,y);
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    while(cin&gt;&gt;n&gt;&gt;m)
    {
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;num[i]);
        bulid(1,1,n);
        while(m--)
        {
            cin&gt;&gt;s;
              
            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
            if(s=='Q')
            {
                printf(&quot;%d\n&quot;,query(1,a,b));
            }
            else
            {
                num[a]=b;
                update(1,a,b);
            }
        }
    }
    return 0;
}
</code></pre></div><h2 id="hdu-1698-just-a-hook"><a href="#hdu-1698-just-a-hook" aria-hidden="true" class="header-anchor">#</a> HDU 1698 Just a Hook</h2> <h3 id="题目大意-3"><a href="#题目大意-3" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>他怎么知道我打dota（逃…）。 将整个区间赋值为同一个数，这里需要用到lazy-tag。额外维护两个域en来表示一个区间是否为统一的数，若en有效，则data表示区间统一的值。</p> <h3 id="代码-3"><a href="#代码-3" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right;
    int delta,data,sum;
    bool en;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void clear(Node *cur)
{
    if(cur-&gt;left!=cur-&gt;right)
    {
        clear(cur-&gt;leftchild);
        clear(cur-&gt;rightchild);
    }
    free(cur);
}
int calcsum(Node *cur)
{
    if(cur-&gt;en)
        return (cur-&gt;right-cur-&gt;left+1)*cur-&gt;data;
    else
        return cur-&gt;sum;
}
void update(Node *cur,int l,int r,int num)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;en)
    {
        if(lc!=NULL)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
        }
        if(rc!=NULL)
        {
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
        }
        cur-&gt;en=false;
    }
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
    {
        cur-&gt;en=true;
        cur-&gt;data=num;
    }
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,num);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,num);
        cur-&gt;sum=calcsum(lc)+calcsum(rc);
    }
}
int querysum(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=calcsum(cur);
    else
    {
        if(cur-&gt;en)
        {
            lc-&gt;data=cur-&gt;data;
            lc-&gt;en=true;
            rc-&gt;data=cur-&gt;data;
            rc-&gt;en=true;
            cur-&gt;en=false;
        }
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=querysum(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+rc-&gt;sum;
    }
    return ret;
}
int main()
{
//    freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d&quot;,&amp;T);
    for(int cnt=1;cnt&lt;=T;cnt++)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
//        root=NULL;
        Node *root=new Node;
        build(root,1,n);
        update(root,1,n,1);
        while(q--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,cnt,querysum(root,1,n));
        clear(root);
    }
    return 0;
}
</code></pre></div><h2 id="poj-3468-a-simple-problem-with-integers"><a href="#poj-3468-a-simple-problem-with-integers" aria-hidden="true" class="header-anchor">#</a> POJ 3468 A Simple Problem with Integers</h2> <h3 id="题目大意-4"><a href="#题目大意-4" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>虽然题干是英文但应该也好懂，将区间整体加上一个数并且询问区间和，同样可以使用lazy-tag进行维护，但注意数据貌似会爆int？</p> <h3 id="代码-4"><a href="#代码-4" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=100000+10;
typedef long long LL;
struct Node
{
    int left,right;
    LL delta,sum;
    Node *leftchild,*rightchild;
};
int T,n,q,x,y,z,num[maxn];
char s;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
        cur-&gt;sum=cur-&gt;leftchild-&gt;sum+cur-&gt;rightchild-&gt;sum;
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
    }
    else
    {
        cur-&gt;sum=num[l];
        //cout&lt;&lt;cur-&gt;sum&lt;&lt;endl;
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
    }
         
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
}
LL query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    LL ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret+=cur-&gt;sum+cur-&gt;delta*(cur-&gt;right-cur-&gt;left+1);
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(lc,l,r);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            ret+=query(rc,l,r);
        cur-&gt;sum=lc-&gt;sum+lc-&gt;delta*(lc-&gt;right-lc-&gt;left+1);
        cur-&gt;sum+=rc-&gt;sum+rc-&gt;delta*(rc-&gt;right-rc-&gt;left+1);
    }
    return ret;
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    Node *root=new Node;
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;num[i]);
    build(root,1,n);
    for(int i=1;i&lt;=q;i++)
    {
        cin&gt;&gt;s;
        if(s=='Q')
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            printf(&quot;%lld\n&quot;,query(root,x,y));
        }
        else
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            update(root,x,y,z);
        }
    }
     
    return 0;
}
</code></pre></div><h2 id="poi-2001-railways"><a href="#poi-2001-railways" aria-hidden="true" class="header-anchor">#</a> POI 2001 Railways</h2> <h3 id="题目大意-5"><a href="#题目大意-5" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>传说中的POI原题哦。同样的可以转化成区间整体加数并且询问区间和的问题。然而这个题目有点坑，一开始提交总是a不掉，最后去POI摸了数据手工对照才发现如果两个区间出现这种情况：[1,3],[3,6]，这样的话即使3这个节点超过了最大值，那么还是可行的。这里我用的处理方法是将区间的上介减1，然后再insert()的方法，具体看代码。</p> <h3 id="代码-5"><a href="#代码-5" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
using namespace std;
struct Node
{
    int left,right;
    int max,delta;
    Node *leftchild,*rightchild;
};
int n,m,r,k1,k2,v;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l,cur-&gt;right=r,cur-&gt;max=0,cur-&gt;delta=0;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int delta)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        cur-&gt;delta+=delta;
    else
    {
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
            update(lc,l,r,delta);
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
            update(rc,l,r,delta);
        //\cur-&gt;max+=cur-&gt;delta;
        //cout&lt;&lt;cur-&gt;max&lt;&lt;endl;
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
}
int query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    int ret=0;
    if((l&lt;=cur-&gt;left)&amp;&amp;(cur-&gt;right&lt;=r))
        ret=cur-&gt;max+cur-&gt;delta;
    else
    {
        lc-&gt;delta+=cur-&gt;delta;
        rc-&gt;delta+=cur-&gt;delta;
        cur-&gt;max+=cur-&gt;delta;
        cur-&gt;delta=0;
        if(l&lt;=(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(lc,l,r);
            ret=max(ret,x);
        }
        if(r&gt;(cur-&gt;left+cur-&gt;right)/2)
        {
            int x=query(rc,l,r);
            ret=max(ret,x);
        }
        cur-&gt;max=max(cur-&gt;max,lc-&gt;max+lc-&gt;delta);
        cur-&gt;max=max(cur-&gt;max,rc-&gt;max+rc-&gt;delta);
    }
    return ret;
}
int main()
{
    //freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;r);
    Node *root=new Node;
    build(root,1,n-1);
    while(r--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;k1,&amp;k2,&amp;v);
        //update(root,k1,k2,v);
        //cout&lt;&lt;query(root,1,4)&lt;&lt;endl;
        int maxx=query(root,k1,k2-1);
        //cout&lt;&lt;maxx&lt;&lt;endl;
        if(maxx+v&lt;=m)
        {
            printf(&quot;T\n&quot;);
            update(root,k1,k2-1,v);
        }
        else
            printf(&quot;F\n&quot;);
    }
    return 0;
}
</code></pre></div><h2 id="poj-2777-count-color"><a href="#poj-2777-count-color" aria-hidden="true" class="header-anchor">#</a> POJ 2777 Count Color</h2> <h3 id="题目大意-6"><a href="#题目大意-6" aria-hidden="true" class="header-anchor">#</a> 题目大意</h3> <p>英文题，但仍然很好懂。将区间整体赋值，并且查询区间中不同数的个数。这个题的技巧在于颜色总共只有30种，那么我们可以用位操作表示每一种颜色，父节点的颜色即为子节点的按位或(or)，最后1的个数即为不同颜色的个数。</p> <h3 id="代码-6"><a href="#代码-6" aria-hidden="true" class="header-anchor">#</a> 代码</h3> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000+10;
struct Node
{
    int left,right,data;
    int color;
    Node *leftchild,*rightchild;
    bool cover;
};
int n,t,o,x,y,z,cnt;
void build(Node *cur,int l,int r)
{
    cur-&gt;left=l;
    cur-&gt;right=r;
    cur-&gt;color=1;
    cur-&gt;cover=false;
    if(l!=r)
    {
        cur-&gt;leftchild=new Node;
        cur-&gt;rightchild=new Node;
        build(cur-&gt;leftchild,l,(l+r)/2);
        build(cur-&gt;rightchild,(l+r)/2+1,r);
    }
    else
        cur-&gt;leftchild=cur-&gt;rightchild=NULL;
}
void update(Node *cur,int l,int r,int value)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;left==l&amp;&amp;cur-&gt;right==r)
    {
        cur-&gt;color=(1&lt;&lt;(value-1));
        cur-&gt;cover=true;
        return;
    }
    if(cur-&gt;cover)
    {
        cur-&gt;cover=false;
        lc-&gt;cover=true;
        rc-&gt;cover=true;
        lc-&gt;color=cur-&gt;color;
        rc-&gt;color=cur-&gt;color;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        update(lc,l,r,value);
    else if(l&gt;mid)
        update(rc,l,r,value);
    else
    {
        update(lc,l,mid,value);
        update(rc,mid+1,r,value);  
    }
    cur-&gt;color=lc-&gt;color|rc-&gt;color;
}
void query(Node *cur,int l,int r)
{
    Node *lc=cur-&gt;leftchild,*rc=cur-&gt;rightchild;
    if(cur-&gt;cover||(cur-&gt;left==l&amp;&amp;cur-&gt;right==r))
    {
        cnt|=cur-&gt;color;
        return;
    }
    int mid=(cur-&gt;left+cur-&gt;right)/2;
    if(r&lt;=mid)
        query(lc,l,r);
    else if(l&gt;mid)
        query(rc,l,r);
    else
    {
        query(lc,l,mid);
        query(rc,mid+1,r); 
    }  
}
int main()
{
//  freopen(&quot;1.sb&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;t,&amp;o);
    Node *root=new Node;
    build(root,1,n);
    while(o--)
    {
        char ch;
        scanf(&quot; %c &quot;,&amp;ch);
        //cout&lt;&lt;ch&lt;&lt;endl;
        //cin&gt;&gt;ch;
        if(ch=='C')
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            if(x&gt;y)
                swap(x,y);
            update(root,x,y,z);
        }
        else
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            if(x&gt;y)
                swap(x,y);
            cnt=0;
            int ans=0;
            query(root,x,y);
            for(int i=0;i&lt;t;i++)
                if(cnt&amp;(1&lt;&lt;i))
                    ans++;
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre></div><h2 id="结语"><a href="#结语" aria-hidden="true" class="header-anchor">#</a> 结语</h2> <p>这些题主要都属于一些模板类的题，但其中也不乏技巧类的东西。而线段树的精髓也在于，当线段完全覆盖一个节点区间时可以直接对这个节点打上标记，而不需要一直做下去。</p></div></div> <!----></div></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.86401502.js" defer></script><script src="/assets/js/9.1d422f60.js" defer></script><script src="/assets/js/143.6ef7193c.js" defer></script>
  </body>
</html>
